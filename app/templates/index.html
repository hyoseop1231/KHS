<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KITECH RAG Chatbot</title>
    <link rel="stylesheet" href="{{ url_for('static', path='/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– KITECH RAG Chatbot</h1>

        <div class="ollama-section">
            <h2>ğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ ëŒ€ì‹œë³´ë“œ</h2>
            
            <!-- ì²« ë²ˆì§¸ ì¤„: LLM & ë¬¸ì„œì²˜ë¦¬ ìƒíƒœ (ê· ë“± ë°°ì¹˜) -->
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; align-items: center; margin-bottom: 15px;">
                <!-- Ollama ìƒíƒœ -->
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">ğŸ§ </span>
                    <div id="ollama-status" style="font-size: 0.9em;">Ollama ìƒíƒœ: í™•ì¸ ì¤‘...</div>
                </div>
                
                <!-- ëª¨ë¸ ì„ íƒ -->
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">âš™ï¸</span>
                    <label for="ollama-models" style="margin: 0; white-space: nowrap; font-size: 0.9em;">ëª¨ë¸:</label>
                    <select id="ollama-models" style="flex: 1; min-width: 0; font-size: 0.85em;">
                        <option value="">ë¡œë”© ì¤‘...</option>
                    </select>
                </div>
                
                <!-- LLM ì‘ë™ ìƒíƒœ -->
                <div id="model-info-container" style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.1em;">ğŸ’­</span>
                    <div id="model-activity" style="display: none; align-items: center; gap: 6px;">
                        <div id="activity-gauge" style="width: 18px; height: 18px; border-radius: 50%; background: conic-gradient(#28a745 0deg, #e9ecef 0deg); position: relative; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 10px; height: 10px; background: white; border-radius: 50%;"></div>
                        </div>
                        <span id="activity-text" style="font-size: 0.8em; color: #28a745; font-weight: 500;">ëŒ€ê¸°ì¤‘</span>
                    </div>
                    <div id="model-info" style="font-size: 0.8em; color: #495057; flex: 1; min-width: 0;">
                        ëª¨ë¸ ì •ë³´ ë¡œë”© ì¤‘...
                    </div>
                </div>
                
                <!-- ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœ -->
                <div id="processing-status-container" style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">ğŸ“„</span>
                    <div id="processing-activity" style="display: flex; align-items: center; gap: 6px;">
                        <div id="processing-gauge" style="width: 18px; height: 18px; border-radius: 50%; background: conic-gradient(#6c757d 0deg, #e9ecef 0deg); position: relative; transition: all 0.3s ease;">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 10px; height: 10px; background: white; border-radius: 50%;"></div>
                        </div>
                        <span id="processing-text" style="font-size: 0.8em; color: #6c757d; font-weight: 500;">ëŒ€ê¸°ì¤‘</span>
                    </div>
                </div>
            </div>
            
            <!-- ë‘ ë²ˆì§¸ ì¤„: ì‹œìŠ¤í…œ í†µê³„ & ë¹ ë¥¸ ì„¤ì • -->
            <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap; padding: 12px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                <!-- ì‹œìŠ¤í…œ í†µê³„ -->
                <div style="display: flex; gap: 20px; flex: 1; min-width: 300px;">
                    <div style="text-align: center;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #495057;" id="doc-count">0</div>
                        <div style="font-size: 0.8em; color: #6c757d;">ë¬¸ì„œ</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #495057;" id="chunk-count">0</div>
                        <div style="font-size: 0.8em; color: #6c757d;">ì²­í¬</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #495057;" id="storage-size">0MB</div>
                        <div style="font-size: 0.8em; color: #6c757d;">ì €ì¥ê³µê°„</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; font-weight: 500; color: #6c757d;" id="last-update">ì—…ë°ì´íŠ¸ ì—†ìŒ</div>
                        <div style="font-size: 0.8em; color: #6c757d;">ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸</div>
                    </div>
                </div>
                
                <!-- ë¹ ë¥¸ ì„¤ì • í† ê¸€ -->
                <div style="display: flex; gap: 15px; align-items: center; border-left: 1px solid #dee2e6; padding-left: 20px;">
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="ocr-correction-toggle" checked style="margin: 0;">
                        <span>ğŸ”§ OCR êµì •</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="llm-correction-toggle" checked style="margin: 0;">
                        <span>ğŸ¤– LLM êµì •</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="auto-refresh-toggle" checked style="margin: 0;">
                        <span>ğŸ”„ ìë™ìƒˆë¡œê³ ì¹¨</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="upload-section">
            <h2>ğŸ“ ë¬¸ì„œ ì—…ë¡œë“œ ë° ì²˜ë¦¬</h2>
            <form id="upload-form">
                <label for="pdf-file">ğŸ“„ PDF ì„ íƒ:</label>
                <input type="file" id="pdf-file" name="files" accept=".pdf" multiple required>
                
                <!-- ì„ íƒëœ íŒŒì¼ ëª©ë¡ í‘œì‹œ -->
                <div id="selected-files-container" style="display:none; margin-top:15px;">
                    <h4 style="margin: 10px 0; color: #495057;">ğŸ“‹ ì„ íƒëœ íŒŒì¼ ëª©ë¡:</h4>
                    <div id="selected-files-list" style="max-height: 200px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 8px; padding: 10px; background: #f8f9fa;">
                        <!-- ì„ íƒëœ íŒŒì¼ë“¤ì´ ì—¬ê¸°ì— ì²´í¬ë°•ìŠ¤ì™€ í•¨ê»˜ í‘œì‹œë©ë‹ˆë‹¤ -->
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center;">
                        <button type="button" id="select-all-btn" style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 0.9em;">ì „ì²´ ì„ íƒ</button>
                        <button type="button" id="deselect-all-btn" style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 0.9em;">ì „ì²´ í•´ì œ</button>
                        <span id="selected-count" style="font-size: 0.9em; color: #6c757d;">0ê°œ íŒŒì¼ ì„ íƒë¨</span>
                    </div>
                </div>
                
                <button type="submit" id="upload-submit-btn">ğŸš€ ì—…ë¡œë“œ ë° ì²˜ë¦¬</button>
            </form>
            <div id="upload-status" class="status-message"></div>
            <div id="progress-container" style="display:none; margin-top:15px; border:1px solid #ddd; border-radius:8px; padding:15px; background:#f8f9fa;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h4 style="margin: 0; color: #495057;">â³ íŒŒì¼ ì²˜ë¦¬ ì§„í–‰ ìƒí™©</h4>
                    <button id="hide-progress" style="background: none; border: none; font-size: 1.2em; cursor: pointer; color: #6c757d;" title="ì§„í–‰ë¥  ì°½ ìˆ¨ê¸°ê¸°">âœ•</button>
                </div>
                
                <!-- ì „ì²´ ì§„í–‰ë¥  -->
                <div id="overall-progress" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span id="overall-progress-text">ì „ì²´ ì§„í–‰ë¥ </span>
                        <span id="overall-progress-count">0/0 ì™„ë£Œ</span>
                    </div>
                    <div style="height:8px; background:#e0e0e0; border-radius:4px; overflow:hidden;">
                        <div id="overall-progress-bar" style="height:100%; width:0%; background:#28a745; transition:width 0.3s;"></div>
                    </div>
                </div>
                
                <!-- ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  ì»¨í…Œì´ë„ˆ -->
                <div id="individual-progress-container">
                    <!-- ê°œë³„ íŒŒì¼ ì§„í–‰ë¥ ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
                </div>
                
                <!-- ì™„ë£Œ í›„ ìë™ ìˆ¨ê¹€ ì„¤ì • -->
                <div style="margin-top: 10px; font-size: 0.9em; color: #6c757d; text-align: center;">
                    <label>
                        <input type="checkbox" id="auto-hide-progress" checked style="margin-right: 5px;">
                        ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ ì‹œ ìë™ìœ¼ë¡œ ìˆ¨ê¸°ê¸° (10ì´ˆ í›„)
                    </label>
                </div>
            </div>
        </div>

        <div class="document-management-section">
            <h2>ğŸ“š ë¬¸ì„œ ê´€ë¦¬ 
                <span id="auto-refresh-indicator" style="font-size: 0.8em; color: #28a745; margin-left: 10px;">
                    ğŸ”„ ìë™ ìƒˆë¡œê³ ì¹¨ í™œì„±í™”
                </span>
            </h2>
            <div style="margin-bottom:15px;">
                <button id="refresh-documents" style="margin-right:10px;">ğŸ”„ ë¬¸ì„œ ëª©ë¡ ìƒˆë¡œê³ ì¹¨</button>
                <button id="storage-stats" style="margin-right:10px;">ğŸ“Š ì €ì¥ì†Œ í†µê³„</button>
                <button id="cleanup-files" style="margin-right:10px;">ğŸ§¹ ê³ ì•„ íŒŒì¼ ì •ë¦¬</button>
                <button id="delete-all-documents" style="background:#dc3545; color:white;">ğŸ—‘ï¸ ëª¨ë“  ë¬¸ì„œ ì‚­ì œ</button>
            </div>
            
            <div id="document-list" style="max-height:200px; overflow-y:auto; border:1px solid #ddd; padding:10px; margin-bottom:15px;">
                <!-- ë¬¸ì„œ ëª©ë¡ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
            </div>
            
            <div id="management-status" class="status-message"></div>
        </div>

        <div class="chat-section">
            <h2>ğŸ’¬ ì±—ë´‡ì—ê²Œ ë¬¼ì–´ë³´ê¸°</h2>
            <!-- ë¬¸ì„œ ì„ íƒ ì˜ì—­ -->
            <div style="background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                    <span style="font-size: 1.1em;">ğŸ“‹</span>
                    <label style="font-weight: 600; color: #495057; margin: 0;">ë¬¸ì„œ ì„ íƒ</label>
                    <span id="document-info" style="font-size: 0.85em; color: #6c757d; margin-left: auto;"></span>
                </div>
                
                <!-- ì „ì²´ ë¬¸ì„œ ì„ íƒ -->
                <div style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 10px; margin: 0; cursor: pointer;">
                        <input type="checkbox" id="select-all-docs" checked style="margin: 0; transform: scale(1.1);">
                        <span style="font-weight: 600; color: #495057;">ğŸ“‘ ì „ì²´ ë¬¸ì„œ</span>
                        <span style="font-size: 0.8em; color: #6c757d; margin-left: auto;">ëª¨ë“  ì €ì¥ëœ ë¬¸ì„œ ì‚¬ìš©</span>
                    </label>
                </div>
                
                <!-- íŠ¹ì • ë¬¸ì„œ ì„ íƒ ì„¹ì…˜ -->
                <div id="specific-doc-section" style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 12px; margin-bottom: 10px; display: none;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <input type="checkbox" id="select-specific-docs" style="margin: 0; transform: scale(1.1);">
                        <span style="font-weight: 600; color: #495057;">ğŸ“„ íŠ¹ì • ë¬¸ì„œ ì„ íƒ</span>
                        <span style="font-size: 0.8em; color: #6c757d; margin-left: auto;">ì›í•˜ëŠ” ë¬¸ì„œë§Œ ì„ íƒ</span>
                    </div>
                    
                    <!-- ê°œë³„ ë¬¸ì„œ ë¦¬ìŠ¤íŠ¸ -->
                    <div id="individual-doc-container" style="display: none; margin-left: 24px; padding-top: 8px; border-top: 1px solid #e9ecef;">
                        <div style="font-size: 0.9em; color: #6c757d; margin-bottom: 8px;">
                            ğŸ¯ ë¬¸ì„œë¥¼ ì„ íƒí•˜ì„¸ìš”:
                        </div>
                        <div id="individual-doc-checkboxes" style="max-height: 140px; overflow-y: auto; padding-right: 4px;">
                            <!-- ê°œë³„ ë¬¸ì„œ ì²´í¬ë°•ìŠ¤ ë¦¬ìŠ¤íŠ¸ê°€ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Compact Horizontal Chat Progress Indicator -->
            <div id="chat-progress" class="chat-progress">
                <div class="progress-header">
                    <div class="progress-title">
                        <span class="progress-icon">ğŸ¤–</span>
                        <span id="progress-main-text">AI ë‹µë³€ ìƒì„± ì¤‘...</span>
                    </div>
                    <div class="progress-details">
                        <span class="progress-time" id="progress-timer">0ì´ˆ</span>
                        <span class="progress-percentage" id="overall-progress-text">0%</span>
                    </div>
                </div>
                
                <div class="progress-bar-container">
                    <div class="progress-bar" id="overall-progress-bar"></div>
                </div>
                
                <div class="chat-progress-steps">
                    <div class="progress-step" data-step="query">
                        <div class="progress-step-icon" data-step="1"></div>
                        <span class="step-title">ì§ˆë¬¸ë¶„ì„</span>
                        <div class="step-status" id="query-status"></div>
                    </div>
                    <div class="step-connector"></div>
                    <div class="progress-step" data-step="embedding">
                        <div class="progress-step-icon" data-step="2"></div>
                        <span class="step-title">ì„ë² ë”©</span>
                        <div class="step-status" id="embedding-status"></div>
                    </div>
                    <div class="step-connector"></div>
                    <div class="progress-step" data-step="search">
                        <div class="progress-step-icon" data-step="3"></div>
                        <span class="step-title">ë¬¸ì„œê²€ìƒ‰</span>
                        <div class="step-status" id="search-status"></div>
                    </div>
                    <div class="step-connector"></div>
                    <div class="progress-step" data-step="generate">
                        <div class="progress-step-icon" data-step="4"></div>
                        <span class="step-title">ë‹µë³€ìƒì„±</span>
                        <div class="step-status" id="generate-status">
                            <div class="response-length" id="response-length" style="display: none;">0ì</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="chat-history">
                <!-- ì±„íŒ… ë©”ì‹œì§€ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
            </div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" placeholder="ğŸ’­ ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”...">
                <button id="send-button" class="btn btn-primary">ğŸ’¬ ì „ì†¡</button>
            </div>
            <div id="chat-status" class="status-message"></div>
        </div>
    </div>

    <script>
        const uploadForm = document.getElementById('upload-form');
        const pdfFile = document.getElementById('pdf-file');
        const uploadStatus = document.getElementById('upload-status');

        const chatHistory = document.getElementById('chat-history');
        const chatMessages = document.getElementById('chat-history'); // Same as chatHistory for message container
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const chatStatus = document.getElementById('chat-status');

        // íŒŒì¼ ì„ íƒ ìƒíƒœ ê´€ë¦¬
        let selectedFilesForUpload = new Set();
        
        // íŒŒì¼ ì„ íƒ ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        pdfFile.addEventListener('change', function(event) {
            const files = Array.from(event.target.files);
            displaySelectedFiles(files);
        });
        
        // ì„ íƒëœ íŒŒì¼ ëª©ë¡ í‘œì‹œ
        function displaySelectedFiles(files) {
            const container = document.getElementById('selected-files-container');
            const filesList = document.getElementById('selected-files-list');
            const selectedCount = document.getElementById('selected-count');
            
            if (files.length === 0) {
                container.style.display = 'none';
                selectedFilesForUpload.clear();
                return;
            }
            
            container.style.display = 'block';
            selectedFilesForUpload.clear();
            
            filesList.innerHTML = '';
            files.forEach((file, index) => {
                selectedFilesForUpload.add(index); // ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  íŒŒì¼ ì„ íƒ
                
                const fileItem = document.createElement('div');
                fileItem.style.cssText = `
                    display: flex; 
                    align-items: center; 
                    padding: 8px 12px; 
                    margin-bottom: 6px; 
                    background: white; 
                    border: 1px solid #dee2e6; 
                    border-radius: 6px;
                    transition: all 0.2s ease;
                `;
                
                fileItem.innerHTML = `
                    <input type="checkbox" id="file-${index}" checked style="margin-right: 10px;">
                    <label for="file-${index}" style="flex: 1; margin: 0; cursor: pointer; font-size: 0.9rem;">
                        ğŸ“„ ${file.name}
                    </label>
                    <span style="font-size: 0.8rem; color: #6c757d;">
                        ${(file.size / 1024 / 1024).toFixed(2)} MB
                    </span>
                `;
                
                const checkbox = fileItem.querySelector(`#file-${index}`);
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        selectedFilesForUpload.add(index);
                        fileItem.style.backgroundColor = 'white';
                    } else {
                        selectedFilesForUpload.delete(index);
                        fileItem.style.backgroundColor = '#f8f9fa';
                    }
                    updateSelectedCount();
                });
                
                filesList.appendChild(fileItem);
            });
            
            updateSelectedCount();
        }
        
        // ì„ íƒëœ íŒŒì¼ ê°œìˆ˜ ì—…ë°ì´íŠ¸
        function updateSelectedCount() {
            const selectedCount = document.getElementById('selected-count');
            const submitBtn = document.getElementById('upload-submit-btn');
            
            selectedCount.textContent = `${selectedFilesForUpload.size}ê°œ íŒŒì¼ ì„ íƒë¨`;
            submitBtn.disabled = selectedFilesForUpload.size === 0;
            
            if (selectedFilesForUpload.size === 0) {
                submitBtn.style.opacity = '0.5';
                submitBtn.style.cursor = 'not-allowed';
            } else {
                submitBtn.style.opacity = '1';
                submitBtn.style.cursor = 'pointer';
            }
        }
        
        // ì „ì²´ ì„ íƒ/í•´ì œ ë²„íŠ¼
        document.getElementById('select-all-btn').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#selected-files-list input[type="checkbox"]');
            checkboxes.forEach((checkbox, index) => {
                checkbox.checked = true;
                selectedFilesForUpload.add(index);
                checkbox.closest('div').style.backgroundColor = 'white';
            });
            updateSelectedCount();
        });
        
        document.getElementById('deselect-all-btn').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#selected-files-list input[type="checkbox"]');
            checkboxes.forEach((checkbox, index) => {
                checkbox.checked = false;
                selectedFilesForUpload.delete(index);
                checkbox.closest('div').style.backgroundColor = '#f8f9fa';
            });
            updateSelectedCount();
        });

        uploadForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            
            // íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘ ì‹œ management ë©”ì‹œì§€ í´ë¦¬ì–´
            if (typeof clearManagementStatus === 'function') {
                clearManagementStatus();
            }
            
            uploadStatus.textContent = 'ì„ íƒëœ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê³  ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...';
            
            // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì²˜ë¦¬ì¤‘'ìœ¼ë¡œ ë³€ê²½
            updateProcessingActivity('processing');
            
            const allFiles = Array.from(pdfFile.files);
            const selectedFiles = allFiles.filter((file, index) => selectedFilesForUpload.has(index));
            
            if (selectedFiles.length === 0) {
                uploadStatus.textContent = 'ì²˜ë¦¬í•  íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.';
                // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ëŒ€ê¸°ì¤‘'ìœ¼ë¡œ ë³µê·€
                updateProcessingActivity('idle');
                return;
            }
            
            const formData = new FormData();
            for (const f of selectedFiles) {
                formData.append('files', f);
            }
            // Include OCR correction flag from dashboard toggle
            const ocrToggle = document.getElementById('ocr-correction-toggle');
            formData.append('ocr_correction_enabled', ocrToggle.checked);
            
            // Include LLM correction flag from dashboard toggle
            const llmToggle = document.getElementById('llm-correction-toggle');
            formData.append('llm_correction_enabled', llmToggle.checked);
            try {
                const response = await fetch('/api/upload_pdf/', {
                    method: 'POST',
                    body: formData,
                });
                const result = await response.json();
                if (response.ok) {
                    if (result.results && Array.isArray(result.results)) {
                        const successfulUploads = [];
                        const errorUploads = [];
                        
                        for (const r of result.results) {
                            if (r.error) {
                                errorUploads.push({filename: r.filename || 'íŒŒì¼ ì—†ìŒ', error: r.error});
                            } else {
                                if(r.document_id) {
                                    successfulUploads.push({
                                        documentId: r.document_id,
                                        filename: r.filename
                                    });
                                }
                            }
                        }
                        
                        // ì˜¤ë¥˜ê°€ ìˆëŠ” ê²½ìš°ë§Œ ë©”ì‹œì§€ í‘œì‹œ
                        if (errorUploads.length > 0) {
                            let errorMsg = '';
                            errorUploads.forEach(error => {
                                errorMsg += `âŒ ${error.filename}: ${error.error}\n`;
                            });
                            uploadStatus.textContent = errorMsg.trim();
                            uploadStatus.className = 'status-message status-error';
                            // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì˜¤ë¥˜'ë¡œ ë³€ê²½
                            updateProcessingActivity('error');
                        } else {
                            // ì„±ê³µí•œ ê²½ìš° ê°„ë‹¨í•œ ë©”ì‹œì§€ë§Œ
                            uploadStatus.textContent = `${successfulUploads.length}ê°œ íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘ë¨`;
                            uploadStatus.className = 'status-message status-success';
                            // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì™„ë£Œ'ë¡œ ë³€ê²½ (100% ì§„í–‰ë¥ )
                            updateProcessingActivity('completed', 100);
                        }
                        
                        // ë‹¤ì¤‘ íŒŒì¼ ì§„í–‰ë¥  ì¶”ì  ì‹œì‘
                        if (successfulUploads.length > 0) {
                            startMultiFileProgressTracking(successfulUploads);
                            
                            // ì„±ê³µ ë©”ì‹œì§€ë¥¼ 3ì´ˆ í›„ ìë™ìœ¼ë¡œ ìˆ¨ê¹€
                            setTimeout(() => {
                                uploadStatus.textContent = '';
                                uploadStatus.className = 'status-message';
                                // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ëŒ€ê¸°ì¤‘'ìœ¼ë¡œ ë³µê·€
                                updateProcessingActivity('idle');
                            }, 3000);
                        }
                        
                        // ë¬¸ì„œ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                        setTimeout(() => {
                            fetchDocumentList();
                        }, 2000);
                    } else {
                        uploadStatus.textContent = 'ì•Œ ìˆ˜ ì—†ëŠ” ì‘ë‹µ í˜•ì‹';
                        uploadStatus.className = 'status-message status-error';
                        // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì˜¤ë¥˜'ë¡œ ë³€ê²½
                        updateProcessingActivity('error');
                    }
                } else {
                    uploadStatus.textContent = `ì˜¤ë¥˜: ${result.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`;
                    uploadStatus.className = 'status-message status-error';
                    // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì˜¤ë¥˜'ë¡œ ë³€ê²½
                    updateProcessingActivity('error');
                }
            } catch (error) {
                uploadStatus.textContent = `ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`;
                uploadStatus.className = 'status-message status-error';
                // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì˜¤ë¥˜'ë¡œ ë³€ê²½
                updateProcessingActivity('error');
            }
        });

        async function sendMessage() {
            const query = chatInput.value.trim();
            if (!query) return;

            appendMessage('user', query);
            chatInput.value = '';
            
            // Show progress indicator
            showChatProgress();
            
            // ëª¨ë¸ í™œë™ ìƒíƒœë¥¼ 'ì²˜ë¦¬ì¤‘'ìœ¼ë¡œ ë³€ê²½
            updateModelActivity('processing');
            
            // Disable send button
            sendButton.disabled = true;
            sendButton.innerHTML = '<span class="loading-spinner"></span>ìƒì„± ì¤‘...';

            // Create streaming message container
            const streamingMessageDiv = document.createElement('div');
            streamingMessageDiv.classList.add('message', 'bot-message', 'streaming');
            const messageContent = document.createElement('div');
            messageContent.classList.add('streaming-content');
            streamingMessageDiv.appendChild(messageContent);
            chatMessages.appendChild(streamingMessageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            try {
                // Debug: Log request details
                console.log('Sending chat request:', {
                    query: query,
                    model_name: getSelectedModel(),
                    document_ids: getSelectedDocumentIds()
                });
                
                // Use EventSource for Server-Sent Events
                const response = await fetch('/api/chat/stream/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        query: query, 
                        model_name: getSelectedModel(), 
                        document_ids: getSelectedDocumentIds() 
                    }),
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // Handle streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullResponse = '';
                let contentSummary = null;
                let mediaReferences = null;
                let isCached = false;
                let markdownTimeout = null;

                // Initialize with first step only
                updateProgressStep('embedding', 'ì§ˆë¬¸ì„ ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤...', 0);

                let buffer = '';
                
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); // Keep incomplete line in buffer

                        for (const line of lines) {
                            if (line.trim().startsWith('data: ')) {
                                try {
                                    const jsonStr = line.trim().substring(6);
                                    if (jsonStr.trim()) {
                                        const data = JSON.parse(jsonStr);
                                        
                                        if (data.type === 'status') {
                                            // Update status message and progress step
                                            chatStatus.textContent = data.message;
                                            chatStatus.className = 'status-message';
                                            
                                            // Update progress step based on status message with proper timing
                                            console.log('Status message received:', data.message); // Debug log
                                            
                                            if (data.message.includes('ì§ˆë¬¸ ë¶„ì„')) {
                                                // Skip - already set in initial step
                                            } else if (data.message.includes('ìºì‹œì—ì„œ ë‹µë³€ì„ ë¶ˆëŸ¬ì˜¤ê³  ìˆìŠµë‹ˆë‹¤')) {
                                                // Cached response - immediately complete embedding and move to search
                                                updateProgressStep('embedding', 'ìºì‹œ í™•ì¸ ì™„ë£Œ!', 100);
                                                setTimeout(() => updateProgressStep('search', 'ìºì‹œëœ ë°ì´í„° ê²€ìƒ‰ ì¤‘...', 50), 50);
                                            } else if (data.message.includes('LLMìœ¼ë¡œ ë‹µë³€ì„ êµ¬ì¡°í™”í•˜ê³  ìˆìŠµë‹ˆë‹¤')) {
                                                // LLM formatting for cached response
                                                updateProgressStep('search', 'ìºì‹œëœ ë°ì´í„° ê²€ìƒ‰ ì™„ë£Œ!', 100);
                                                setTimeout(() => updateProgressStep('generate', 'ğŸ’¾ ìºì‹œëœ ë‹µë³€ì„ êµ¬ì¡°í™”í•˜ê³  ìˆìŠµë‹ˆë‹¤...', 30), 50);
                                            } else if (data.message.includes('ê´€ë ¨ ë¬¸ì„œ ê²€ìƒ‰')) {
                                                // Mark embedding as complete and move to search
                                                updateProgressStep('embedding', 'ì„ë² ë”© ìƒì„± ì™„ë£Œ!', 100);
                                                setTimeout(() => updateProgressStep('search', data.message), 300);
                                            } else if (data.message.includes('ë‹µë³€ ìƒì„±')) {
                                                // Mark search as complete and move to generate
                                                updateProgressStep('search', 'ë¬¸ì„œ ê²€ìƒ‰ ì™„ë£Œ!', 100);
                                                setTimeout(() => updateProgressStep('generate', data.message), 300);
                                            }
                                        } else if (data.type === 'content') {
                                            // First content chunk - ensure we're in generate step
                                            if (fullResponse === '') {
                                                console.log('First content chunk received:', { cached: data.cached, content: data.content.substring(0, 50) });
                                                if (data.cached) {
                                                    // For cached responses, immediately complete all steps
                                                    updateProgressStep('embedding', 'ì„ë² ë”© ì™„ë£Œ!', 100);
                                                    setTimeout(() => {
                                                        updateProgressStep('search', 'ê²€ìƒ‰ ì™„ë£Œ!', 100);
                                                        setTimeout(() => {
                                                            updateProgressStep('generate', 'ğŸ’¾ ìºì‹œëœ ë‹µë³€ì„ ë¡œë”© ì¤‘...', 60);
                                                        }, 50);
                                                    }, 50);
                                                } else {
                                                    updateProgressStep('generate', 'AIê°€ ë‹µë³€ì„ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...');
                                                }
                                            }
                                            
                                            // Append content to streaming message
                                            fullResponse += data.content;
                                            console.log('Content appended, fullResponse length:', fullResponse.length, 'cached:', data.cached);
                                            
                                            // Update response progress with detailed metrics
                                            const responseLength = fullResponse.length;
                                            const wordCount = fullResponse.trim().split(/\s+/).length;
                                            
                                            if (!data.cached) {
                                                const estimatedTotal = Math.max(wordCount * 2, 50);
                                                
                                                // Only update progress if we have meaningful content
                                                if (wordCount > 2) {
                                                    const progress = Math.min((wordCount / estimatedTotal) * 100, 95);
                                                    updateProgressStep('generate', `AIê°€ ë‹µë³€ì„ ì‘ì„±í•˜ëŠ” ì¤‘... (${wordCount}ë‹¨ì–´)`, progress, {
                                                        responseLength: responseLength
                                                    });
                                                }
                                            } else {
                                                // For cached responses, show realistic completion progress
                                                let progress;
                                                if (responseLength < 100) {
                                                    progress = 70;
                                                } else if (responseLength < 500) {
                                                    progress = 80;
                                                } else if (responseLength < 1000) {
                                                    progress = 90;
                                                } else {
                                                    progress = 95;
                                                }
                                                updateProgressStep('generate', 'ğŸ’¾ ìºì‹œëœ ë‹µë³€ ë¡œë”© ì¤‘...', progress, {
                                                    responseLength: responseLength
                                                });
                                            }
                                            
                                            // Apply markdown formatting with debouncing to reduce flickering
                                            if (markdownTimeout) {
                                                clearTimeout(markdownTimeout);
                                            }
                                            
                                            // For cached responses, apply markdown immediately for better formatting
                                            if (data.cached && window.marked) {
                                                try {
                                                    messageContent.innerHTML = window.marked.parse(fullResponse);
                                                } catch (markdownError) {
                                                    messageContent.textContent = fullResponse;
                                                }
                                            } else {
                                                // Show text immediately for non-cached responses
                                                messageContent.textContent = fullResponse;
                                                
                                                // Apply markdown after a short delay to reduce flickering
                                                if (window.marked) {
                                                    markdownTimeout = setTimeout(() => {
                                                        try {
                                                            messageContent.innerHTML = window.marked.parse(fullResponse);
                                                        } catch (markdownError) {
                                                            // Keep as text if markdown parsing fails
                                                            messageContent.textContent = fullResponse;
                                                        }
                                                        chatMessages.scrollTop = chatMessages.scrollHeight;
                                                    }, 100); // 100ms debounce
                                                }
                                            }
                                            
                                            chatMessages.scrollTop = chatMessages.scrollHeight;
                                            
                                            if (data.cached) {
                                                isCached = true;
                                            }
                                        } else if (data.type === 'final') {
                                            // Store metadata
                                            contentSummary = data.metadata.content_summary;
                                            mediaReferences = data.metadata.media_references;
                                            isCached = data.metadata.cached;
                                            
                                            console.log('Final metadata received:', { isCached, contentSummary, mediaReferences });
                                            
                                            // For cached responses, complete progress immediately
                                            if (isCached) {
                                                updateProgressStep('generate', 'ğŸ’¾ ìºì‹œëœ ë‹µë³€ ë¡œë”© ì™„ë£Œ!', 100);
                                            }
                                        } else if (data.type === 'error') {
                                            throw new Error(data.message);
                                        }
                                    }
                                } catch (parseError) {
                                    console.warn('Failed to parse SSE data:', line, parseError);
                                }
                            }
                        }
                    }
                } catch (streamError) {
                    console.error('Streaming read error:', streamError);
                    throw streamError;
                } finally {
                    // Ensure reader cleanup
                    try {
                        reader.releaseLock();
                    } catch (releaseError) {
                        console.warn('Failed to release reader lock:', releaseError);
                    }
                }

                // Remove streaming class and finalize message
                streamingMessageDiv.classList.remove('streaming');
                
                // Clear any pending markdown timeout
                if (markdownTimeout) {
                    clearTimeout(markdownTimeout);
                }
                
                // Always convert to enhanced multimodal message format for consistent styling
                if (fullResponse) {
                    console.log('Converting to enhanced multimodal message:', {
                        responseLength: fullResponse.length,
                        isCached: isCached,
                        hasMediaReferences: !!mediaReferences,
                        hasContentSummary: !!contentSummary,
                        streamingDivExists: !!streamingMessageDiv.parentNode
                    });
                    
                    // Don't skip conversion for cached responses - ensure they get proper formatting
                    
                    // Create enhanced multimodal message (works for both cached and regular responses)
                    const enhancedMessageDiv = createEnhancedMultimodalMessage({
                        response: fullResponse,
                        media_references: mediaReferences || null,
                        content_summary: contentSummary || null,
                        cached: isCached
                    });
                    
                    // Replace streaming message with enhanced version
                    if (streamingMessageDiv.parentNode) {
                        streamingMessageDiv.parentNode.replaceChild(enhancedMessageDiv, streamingMessageDiv);
                        console.log('Message converted to enhanced multimodal format');
                    } else {
                        console.warn('Streaming message div not found in DOM');
                    }
                } else {
                    // Fallback for empty responses
                    if (window.marked && fullResponse) {
                        try {
                            messageContent.innerHTML = window.marked.parse(fullResponse);
                        } catch (markdownError) {
                            messageContent.textContent = fullResponse;
                        }
                    }
                }
                
                // Update status with summary
                chatStatus.className = 'status-message status-success';
                if (contentSummary) {
                    const summaryText = `í…ìŠ¤íŠ¸: ${contentSummary.text_chunks || 0}ê°œ, ì´ë¯¸ì§€: ${contentSummary.images || 0}ê°œ, í‘œ: ${contentSummary.tables || 0}ê°œ`;
                    const cacheIndicator = isCached ? ' (ìºì‹œë¨)' : '';
                    chatStatus.textContent = `âœ… ë‹µë³€ ìƒì„± ì™„ë£Œ (${summaryText})${cacheIndicator}`;
                } else {
                    const cacheIndicator = isCached ? ' (ìºì‹œë¨)' : '';
                    chatStatus.textContent = `âœ… ë‹µë³€ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤${cacheIndicator}`;
                }
                
                setTimeout(() => {
                    chatStatus.textContent = '';
                    chatStatus.className = 'status-message';
                }, 5000);

            } catch (error) {
                console.error('Streaming error:', error);
                console.error('Error details:', error.stack);
                console.error('Request context:', {
                    query: query,
                    model_name: getSelectedModel(),
                    document_ids: getSelectedDocumentIds(),
                    timestamp: new Date().toISOString()
                });
                
                // Remove failed streaming message
                if (streamingMessageDiv.parentNode) {
                    streamingMessageDiv.parentNode.removeChild(streamingMessageDiv);
                }
                
                // Detailed error message based on error type
                let errorMessage = 'âŒ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ';
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    errorMessage += 'ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.';
                } else if (error.name === 'AbortError' || error.message.includes('aborted')) {
                    errorMessage += 'ìš”ì²­ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.';
                } else if (error.message.includes('timeout')) {
                    errorMessage += 'ìš”ì²­ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
                } else if (error.message.includes('HTTP error')) {
                    errorMessage += `ì„œë²„ ì˜¤ë¥˜ (${error.message})`;
                } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
                    errorMessage += 'ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.';
                } else {
                    errorMessage += error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
                }
                
                appendMessage('bot', errorMessage);
                chatStatus.className = 'status-message status-error';
                chatStatus.textContent = errorMessage;
            } finally {
                // Hide progress indicator and re-enable button
                hideChatProgress();
                sendButton.disabled = false;
                sendButton.innerHTML = 'ğŸ’¬ ì „ì†¡';
                
                // ëª¨ë¸ í™œë™ ìƒíƒœë¥¼ 'ëŒ€ê¸°ì¤‘'ìœ¼ë¡œ ë³µê·€
                updateModelActivity('idle');
            }
        }

        sendButton.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        function appendMessage(sender, text, isMarkdown=false) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            messageDiv.classList.add(sender === 'user' ? 'user-message' : 'bot-message');
            if(isMarkdown && window.marked) {
                messageDiv.innerHTML = window.marked.parse(text);
            } else {
                messageDiv.textContent = text;
            }
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight; // Scroll to bottom
        }
        
        function createEnhancedMultimodalMessage(result) {
            console.log('Creating enhanced multimodal message:', { cached: result.cached, responseLength: result.response?.length });
            
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'bot-message', 'multimodal-message');
            
            // Add cache indicator if applicable
            if (result.cached) {
                messageDiv.classList.add('cached-message');
                const cacheIndicator = document.createElement('div');
                cacheIndicator.classList.add('cache-indicator');
                cacheIndicator.innerHTML = 'ğŸ’¾ ìºì‹œëœ ì‘ë‹µ (êµ¬ì¡°í™” ì™„ë£Œ)';
                messageDiv.appendChild(cacheIndicator);
            }
            
            // ë©”ì¸ ë‹µë³€ í…ìŠ¤íŠ¸ (ìºì‹œëœ ì‘ë‹µì— ëŒ€í•´ ê°•ì œ ë§ˆí¬ë‹¤ìš´ ì²˜ë¦¬)
            const responseDiv = document.createElement('div');
            responseDiv.classList.add('response-text');
            
            // Force markdown parsing for all responses, especially cached ones
            if (window.marked && result.response) {
                try {
                    console.log('Applying markdown to response:', { 
                        cached: result.cached, 
                        responseLength: result.response.length,
                        preview: result.response.substring(0, 100),
                        markedAvailable: !!window.marked
                    });
                    
                    // Configure marked with enhanced options for better formatting
                    if (window.marked.setOptions) {
                        window.marked.setOptions({
                            breaks: true,
                            gfm: true,
                            tables: true
                        });
                    }
                    
                    // For cached responses, ensure proper markdown parsing
                    const parsedHtml = window.marked.parse(result.response);
                    responseDiv.innerHTML = parsedHtml;
                    
                    // Apply additional styling for tables and code blocks
                    responseDiv.querySelectorAll('table').forEach(table => {
                        table.style.cssText = 'border-collapse: collapse; width: 100%; margin: 1rem 0;';
                        table.querySelectorAll('th, td').forEach(cell => {
                            cell.style.cssText = 'border: 1px solid #ddd; padding: 8px; text-align: left;';
                        });
                        table.querySelectorAll('th').forEach(header => {
                            header.style.cssText += 'background-color: #f2f2f2; font-weight: bold;';
                        });
                    });
                    
                    // Style code blocks
                    responseDiv.querySelectorAll('pre').forEach(pre => {
                        pre.style.cssText = 'background-color: #f8f9fa; padding: 1rem; border-radius: 4px; overflow-x: auto; border-left: 4px solid #007bff;';
                    });
                    
                    console.log('Markdown parsing successful, HTML length:', parsedHtml.length);
                    
                } catch (markdownError) {
                    console.error('Markdown parsing failed:', markdownError);
                    responseDiv.textContent = result.response;
                }
            } else {
                console.warn('Marked not available or no response text');
                responseDiv.textContent = result.response || '';
            }
            messageDiv.appendChild(responseDiv);
            
            // Content summary (show for both cached and regular responses)
            if (result.content_summary && Object.keys(result.content_summary).length > 0) {
                const summaryDiv = document.createElement('div');
                summaryDiv.classList.add('content-summary');
                const summary = result.content_summary;
                
                // Check if we have any meaningful content to display
                const hasContent = (summary.text_chunks && summary.text_chunks > 0) || 
                                  (summary.images && summary.images > 0) || 
                                  (summary.tables && summary.tables > 0);
                
                if (hasContent) {
                    summaryDiv.innerHTML = `
                        <div class="summary-title">ğŸ“Š ì°¸ì¡° ì½˜í…ì¸ </div>
                        <div class="summary-items">
                            <span class="summary-item">ğŸ“„ í…ìŠ¤íŠ¸: ${summary.text_chunks || 0}ê°œ</span>
                            <span class="summary-item">ğŸ–¼ï¸ ì´ë¯¸ì§€: ${summary.images || 0}ê°œ</span>
                            <span class="summary-item">ğŸ“‹ í‘œ: ${summary.tables || 0}ê°œ</span>
                        </div>
                    `;
                    messageDiv.appendChild(summaryDiv);
                }
            }
            
            // Media references
            if (result.media_references && result.media_references.has_media) {
                const mediaDiv = document.createElement('div');
                mediaDiv.classList.add('media-content');
                
                // Referenced images
                if (result.media_references.images && result.media_references.images.length > 0) {
                    const imagesDiv = document.createElement('div');
                    imagesDiv.classList.add('referenced-media');
                    imagesDiv.innerHTML = '<h4>ğŸ–¼ï¸ ì°¸ì¡°ëœ ì´ë¯¸ì§€</h4>';
                    
                    result.media_references.images.forEach(img => {
                        const imgContainer = document.createElement('div');
                        imgContainer.classList.add('media-item');
                        imgContainer.innerHTML = `
                            <img src="${img.path}" alt="${img.metadata || 'Referenced image'}" 
                                 loading="lazy" style="max-width: 300px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div class="media-caption">${img.metadata || 'ì´ë¯¸ì§€'}</div>
                        `;
                        imagesDiv.appendChild(imgContainer);
                    });
                    mediaDiv.appendChild(imagesDiv);
                }
                
                // Referenced tables
                if (result.media_references.tables && result.media_references.tables.length > 0) {
                    const tablesDiv = document.createElement('div');
                    tablesDiv.classList.add('referenced-media');
                    tablesDiv.innerHTML = '<h4>ğŸ“‹ ì°¸ì¡°ëœ í‘œ</h4>';
                    
                    result.media_references.tables.forEach(table => {
                        const tableContainer = document.createElement('div');
                        tableContainer.classList.add('media-item');
                        tableContainer.innerHTML = `
                            <img src="${table.path}" alt="${table.metadata || 'Referenced table'}" 
                                 loading="lazy" style="max-width: 400px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div class="media-caption">${table.metadata || 'í‘œ'}</div>
                        `;
                        tablesDiv.appendChild(tableContainer);
                    });
                    mediaDiv.appendChild(tablesDiv);
                }
                
                messageDiv.appendChild(mediaDiv);
            }
            
            return messageDiv;
        }

        function appendMultimodalMessage(sender, result) {
            const messageDiv = createEnhancedMultimodalMessage(result);
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        // Enhanced chat progress functions with real-time status updates
        function showChatProgress() {
            const progressEl = document.getElementById('chat-progress');
            const progressMessage = document.getElementById('chat-progress-message');
            
            progressEl.classList.add('active');
            
            // Reset all steps
            document.querySelectorAll('.progress-step').forEach(step => {
                step.classList.remove('active', 'completed');
            });
            
            // Start with query analysis step and auto-progress
            updateProgressStep('query', 'ì§ˆë¬¸ì„ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤...');
            
            // Auto-progress through query step very quickly
            setTimeout(() => {
                updateProgressStep('query', 'ì§ˆë¬¸ ë¶„ì„ ì™„ë£Œ!', 100);
            }, 150);
        }
        
        function updateProgressStep(stepName, message, percentage = null, details = {}) {
            const progressEl = document.getElementById('chat-progress');
            const progressMainText = document.getElementById('progress-main-text');
            const steps = ['query', 'embedding', 'search', 'generate'];
            
            console.log(`ğŸ“Š Progress Update: ${stepName} - ${message} (${percentage || 0}%)`, details);
            
            // Update main progress text
            if (progressMainText) {
                progressMainText.textContent = message;
            }
            
            // Update overall progress bar
            const currentIndex = steps.indexOf(stepName);
            const baseProgress = (currentIndex / steps.length) * 100;
            const stepProgress = (percentage || 0) / steps.length;
            const overallProgress = Math.min(baseProgress + stepProgress, 100);
            
            const overallProgressBar = document.getElementById('overall-progress-bar');
            const overallProgressText = document.getElementById('overall-progress-text');
            if (overallProgressBar) {
                overallProgressBar.style.width = `${overallProgress}%`;
            }
            if (overallProgressText) {
                overallProgressText.textContent = `${Math.round(overallProgress)}%`;
            }
            
            // Update timer
            if (!progressEl.startTime) {
                progressEl.startTime = Date.now();
                progressEl.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - progressEl.startTime) / 1000);
                    const timerEl = document.getElementById('progress-timer');
                    if (timerEl) {
                        timerEl.textContent = `${elapsed}ì´ˆ`;
                    }
                }, 1000);
            }
            
            // Mark previous steps as completed
            for (let i = 0; i < currentIndex; i++) {
                const stepEl = document.querySelector(`[data-step="${steps[i]}"]`);
                if (stepEl && !stepEl.classList.contains('completed')) {
                    stepEl.classList.remove('active', 'pending');
                    stepEl.classList.add('completed');
                    
                    // Update status to completed
                    const statusEl = stepEl.querySelector('.step-status');
                    if (statusEl) {
                        statusEl.innerHTML = '<div class="step-check">âœ“</div>';
                    }
                    
                    console.log(`âœ… Marked ${steps[i]} as completed`);
                }
            }
            
            // Mark current step as active
            const currentStepEl = document.querySelector(`[data-step="${stepName}"]`);
            if (currentStepEl) {
                currentStepEl.classList.remove('completed', 'pending');
                currentStepEl.classList.add('active');
                
                // Update step status
                const statusEl = document.getElementById(`${stepName}-status`);
                if (statusEl) {
                    if (percentage !== null && percentage >= 100) {
                        statusEl.innerHTML = '<div class="step-check">âœ“</div>';
                    } else {
                        const spinnerHtml = '<div class="step-spinner"></div>';
                        statusEl.innerHTML = spinnerHtml;
                    }
                }
                
                // Special handling for generate step
                if (stepName === 'generate' && details.responseLength) {
                    const responseLengthEl = document.getElementById('response-length');
                    if (responseLengthEl) {
                        responseLengthEl.textContent = `${details.responseLength}ì`;
                        responseLengthEl.style.display = 'inline-block';
                    }
                }
            }
            
            // Mark future steps as pending
            for (let i = currentIndex + 1; i < steps.length; i++) {
                const stepEl = document.querySelector(`[data-step="${steps[i]}"]`);
                if (stepEl) {
                    stepEl.classList.remove('active', 'completed');
                    stepEl.classList.add('pending');
                }
            }
            
            // Update message with typing effect for generate step
            if (stepName === 'generate' && message.includes('ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤')) {
                if (progressMainText) {
                    showTypingEffect(progressMainText, message);
                }
            } else {
                if (progressMainText) {
                    progressMainText.textContent = message;
                }
            }
        }
        
        function showTypingEffect(element, baseMessage) {
            let dots = 0;
            const typingInterval = setInterval(() => {
                dots = (dots + 1) % 4;
                element.textContent = baseMessage + '.'.repeat(dots);
            }, 500);
            
            // Store interval for cleanup
            const progressEl = document.getElementById('chat-progress');
            progressEl.typingInterval = typingInterval;
        }
        
        function updateResponseProgress(wordCount, estimatedTotal) {
            const percentage = Math.min(Math.round((wordCount / estimatedTotal) * 100), 95);
            const message = `ë‹µë³€ ìƒì„± ì¤‘... (${wordCount}/${estimatedTotal} ë‹¨ì–´)`;
            updateProgressStep('generate', message, percentage);
        }
        
        function hideChatProgress() {
            const progressEl = document.getElementById('chat-progress');
            
            // Add completion animation before hiding
            progressEl.classList.add('completing');
            
            // Update final status
            const overallProgressBar = document.getElementById('overall-progress-bar');
            const overallProgressText = document.getElementById('overall-progress-text');
            const progressMainText = document.getElementById('progress-main-text');
            if (overallProgressBar) overallProgressBar.style.width = '100%';
            if (overallProgressText) overallProgressText.textContent = '100%';
            if (progressMainText) progressMainText.textContent = 'ë‹µë³€ ìƒì„± ì™„ë£Œ! ğŸ‰';
            
            // Mark all steps as completed
            document.querySelectorAll('.progress-step').forEach(step => {
                step.classList.remove('active', 'pending');
                step.classList.add('completed');
                const statusEl = step.querySelector('.step-status');
                if (statusEl) {
                    statusEl.innerHTML = '<div class="step-check">âœ“</div>';
                }
            });
            
            // Clear timers
            if (progressEl.timerInterval) {
                clearInterval(progressEl.timerInterval);
                progressEl.timerInterval = null;
            }
            if (progressEl.stepInterval) {
                clearInterval(progressEl.stepInterval);
                progressEl.stepInterval = null;
            }
            if (progressEl.typingInterval) {
                clearInterval(progressEl.typingInterval);
                progressEl.typingInterval = null;
            }
            
            // Hide after animation
            setTimeout(() => {
                progressEl.classList.remove('active', 'completing');
                
                // Reset for next use
                setTimeout(() => {
                    document.querySelectorAll('.progress-step').forEach(step => {
                        step.classList.remove('active', 'completed', 'pending');
                    });
                    if (overallProgressBar) overallProgressBar.style.width = '0%';
                    if (overallProgressText) overallProgressText.textContent = '0%';
                    if (progressMainText) progressMainText.textContent = 'AI ë‹µë³€ ìƒì„± ì¤‘...';
                    const responseLengthEl = document.getElementById('response-length');
                    if (responseLengthEl) {
                        responseLengthEl.style.display = 'none';
                        responseLengthEl.textContent = '0ì';
                    }
                    progressEl.startTime = null;
                }, 500);
            }, 1500);
        }

        // Ollama ìƒíƒœ ë° ëª¨ë¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
        async function fetchOllamaStatusAndModels() {
            const statusEl = document.getElementById('ollama-status');
            // ìƒíƒœ
            try {
                const res = await fetch('/api/ollama/status');
                const data = await res.json();
                const status = data.status === 'running' ? 'âœ… ì‹¤í–‰ ì¤‘' : (data.status === 'not running' ? 'âŒ ì¤‘ì§€ë¨' : 'â“ ' + data.status);
                statusEl.textContent = 'Ollama ìƒíƒœ: ' + status;
                statusEl.className = 'status-display ' + (data.status === 'running' ? 'status-running' : 'status-stopped');
            } catch (e) {
                statusEl.textContent = 'Ollama ìƒíƒœ: âŒ í™•ì¸ ì‹¤íŒ¨';
                statusEl.className = 'status-display status-stopped';
            }
            // ëª¨ë¸ ëª©ë¡
            try {
                const res = await fetch('/api/ollama/models');
                const data = await res.json();
                const select = document.getElementById('ollama-models');
                
                // í˜„ì¬ ì„ íƒëœ ëª¨ë¸ ì €ì¥ (ìˆë‹¤ë©´)
                const currentSelected = select.value;
                
                select.innerHTML = '';
                if (data.models && data.models.length > 0) {
                    let gemma3Found = false;
                    let defaultModel = null;
                    
                    data.models.forEach((model, index) => {
                        const opt = document.createElement('option');
                        opt.value = model;
                        opt.textContent = formatModelName(model);
                        select.appendChild(opt);
                        
                        // Gemma3 ëª¨ë¸ ì°¾ê¸° (gemma2ë‚˜ gemmaë¡œ ì‹œì‘í•˜ëŠ” ëª¨ë¸ ìš°ì„  ì„ íƒ)
                        if (!gemma3Found && (model.toLowerCase().includes('gemma2') || model.toLowerCase().includes('gemma'))) {
                            gemma3Found = true;
                            defaultModel = model;
                        }
                        
                        // ì²« ë²ˆì§¸ ëª¨ë¸ì„ ë°±ì—…ìœ¼ë¡œ ì €ì¥
                        if (!defaultModel) {
                            defaultModel = model;
                        }
                        
                        // ì´ì „ì— ì„ íƒëœ ëª¨ë¸ì´ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì„ íƒ
                        if (currentSelected && model === currentSelected) {
                            opt.selected = true;
                        }
                    });
                    
                    // ì´ì „ ì„ íƒì´ ì—†ìœ¼ë©´ Gemma ëª¨ë¸ ë˜ëŠ” ì²« ë²ˆì§¸ ëª¨ë¸ ì„ íƒ
                    if (!currentSelected && defaultModel) {
                        select.value = defaultModel;
                        // í•´ë‹¹ ì˜µì…˜ì„ ì„ íƒ ìƒíƒœë¡œ ë§Œë“¤ê¸°
                        const targetOption = select.querySelector(`option[value="${defaultModel}"]`);
                        if (targetOption) {
                            targetOption.selected = true;
                        }
                    }
                    
                    // í˜„ì¬ ì„ íƒëœ ëª¨ë¸ í‘œì‹œ ì—…ë°ì´íŠ¸
                    updateSelectedModelDisplay();
                } else {
                    const opt = document.createElement('option');
                    opt.value = '';
                    opt.textContent = 'ëª¨ë¸ ì—†ìŒ';
                    select.appendChild(opt);
                }
            } catch (e) {
                const select = document.getElementById('ollama-models');
                select.innerHTML = '';
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'ëª¨ë¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨';
                select.appendChild(opt);
            }
        }
        function getSelectedModel() {
            const select = document.getElementById('ollama-models');
            return select.value;
        }
        
        // ëª¨ë¸ëª… ê°„ë‹¨í•˜ê²Œ í¬ë§·
        function formatModelName(fullModelName) {
            if (!fullModelName) return fullModelName;
            
            // ì¼ë°˜ì ì¸ íŒ¨í„´ë“¤ ì²˜ë¦¬
            const patterns = [
                // llama2:7b -> Llama2 (7B)
                { regex: /^(\w+):(\d+\.?\d*b?)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
                // qwen2:1.5b -> Qwen2 (1.5B)
                { regex: /^(\w+\d*):(\d+\.?\d*b?)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
                // gemma:2b-instruct -> Gemma (2B-Instruct)
                { regex: /^(\w+):(\d+\.?\d*b?-?\w*)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
                // llama2:latest -> Llama2 (Latest)
                { regex: /^(\w+):latest$/i, format: (match) => `${capitalize(match[1])} (Latest)` },
                // codellama:13b-code -> CodeLlama (13B-Code)
                { regex: /^(\w+):(\d+\.?\d*b?-?\w*)$/i, format: (match) => `${capitalize(match[1])} (${match[2].toUpperCase()})` },
            ];
            
            for (const pattern of patterns) {
                const match = fullModelName.match(pattern.regex);
                if (match) {
                    return pattern.format(match);
                }
            }
            
            // ë§¤ì¹­ë˜ì§€ ì•ŠëŠ” ê²½ìš° ì²« ë²ˆì§¸ ë¶€ë¶„ë§Œ ì‚¬ìš©í•˜ê±°ë‚˜ ì „ì²´ ì´ë¦„ ì‚¬ìš©
            if (fullModelName.includes(':')) {
                const parts = fullModelName.split(':');
                return `${capitalize(parts[0])} (${parts[1]})`;
            }
            
            return capitalize(fullModelName);
        }
        
        // ì²« ê¸€ìë¥¼ ëŒ€ë¬¸ìë¡œ ë³€í™˜
        function capitalize(str) {
            if (!str) return str;
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        
        // í˜„ì¬ ì„ íƒëœ ëª¨ë¸ í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateSelectedModelDisplay() {
            const select = document.getElementById('ollama-models');
            const selectedModel = select.value;
            
            if (selectedModel) {
                select.style.color = '#495057';
                select.style.fontWeight = '500';
                
                // ëª¨ë¸ ì •ë³´ ì—…ë°ì´íŠ¸
                updateModelInfo(selectedModel);
            }
        }
        
        // ëª¨ë¸ ì •ë³´ ì—…ë°ì´íŠ¸ (ê°œì„ ëœ ë²„ì „)
        function updateModelInfo(modelName) {
            const modelInfoEl = document.getElementById('model-info');
            const activityEl = document.getElementById('model-activity');
            
            if (!modelName) {
                modelInfoEl.textContent = 'ëª¨ë¸ ì„ íƒë˜ì§€ ì•ŠìŒ';
                activityEl.style.display = 'none';
                return;
            }
            
            // ëª¨ë¸ ìƒì„¸ ì •ë³´ ì¶”ì •
            const modelInfo = getModelInfo(modelName);
            modelInfoEl.innerHTML = `
                <div style="line-height: 1.3;">
                    <div style="font-weight: 600; color: #2c3e50; font-size: 0.9em;">
                        ${modelInfo.vendor} â€¢ ${modelInfo.size}
                    </div>
                    <div style="font-size: 0.75em; color: #6c757d;">
                        ${modelInfo.type} â€¢ ${modelInfo.language}
                    </div>
                </div>
            `;
            
            // ì‘ë™ ìƒíƒœ í‘œì‹œ
            activityEl.style.display = 'flex';
            updateModelActivity('idle');
        }
        
        // ëª¨ë¸ ì •ë³´ ì¶”ì • (ê°œì„ ëœ ë²„ì „)
        function getModelInfo(modelName) {
            const name = modelName.toLowerCase();
            
            // ì œì‘ì‚¬ ì¶”ì •
            let vendor = 'Unknown';
            if (name.includes('llama')) vendor = 'Meta';
            else if (name.includes('gemma')) vendor = 'Google';
            else if (name.includes('qwen')) vendor = 'Alibaba';
            else if (name.includes('mistral')) vendor = 'Mistral AI';
            else if (name.includes('phi')) vendor = 'Microsoft';
            else if (name.includes('codellama')) vendor = 'Meta';
            else if (name.includes('vicuna')) vendor = 'LMSYS';
            else if (name.includes('alpaca')) vendor = 'Stanford';
            else if (name.includes('wizardlm')) vendor = 'WizardLM';
            else if (name.includes('nous')) vendor = 'Nous Research';
            
            // í¬ê¸° ì¶”ì •
            let size = 'í¬ê¸° ë¶ˆëª…';
            if (name.includes('0.5b')) size = '0.5B';
            else if (name.includes('1b')) size = '1B';
            else if (name.includes('1.5b')) size = '1.5B';
            else if (name.includes('2b')) size = '2B';
            else if (name.includes('3b')) size = '3B';
            else if (name.includes('7b')) size = '7B';
            else if (name.includes('8b')) size = '8B';
            else if (name.includes('9b')) size = '9B';
            else if (name.includes('13b')) size = '13B';
            else if (name.includes('14b')) size = '14B';
            else if (name.includes('20b')) size = '20B';
            else if (name.includes('30b') || name.includes('33b')) size = '30B+';
            else if (name.includes('70b')) size = '70B';
            else if (name.includes('180b')) size = '180B';
            
            // íƒ€ì… ì¶”ì •
            let type = 'ì¼ë°˜í˜•';
            if (name.includes('instruct')) type = 'ì§€ì‹œ íŠ¹í™”';
            else if (name.includes('chat')) type = 'ëŒ€í™” íŠ¹í™”';
            else if (name.includes('code')) type = 'ì½”ë”© íŠ¹í™”';
            else if (name.includes('vision')) type = 'ë¹„ì „ ëª¨ë¸';
            else if (name.includes('math')) type = 'ìˆ˜í•™ íŠ¹í™”';
            else if (name.includes('reasoning')) type = 'ì¶”ë¡  íŠ¹í™”';
            
            // ì–¸ì–´ ì§€ì› ì¶”ì •
            let language = 'ë‹¤êµ­ì–´';
            if (name.includes('ko') || name.includes('korean')) language = 'í•œêµ­ì–´ íŠ¹í™”';
            else if (name.includes('en') || name.includes('english')) language = 'ì˜ì–´ íŠ¹í™”';
            else if (name.includes('zh') || name.includes('chinese')) language = 'ì¤‘êµ­ì–´ íŠ¹í™”';
            else if (name.includes('jp') || name.includes('japanese')) language = 'ì¼ë³¸ì–´ íŠ¹í™”';
            
            return { vendor, size, type, language };
        }
        
        // ëª¨ë¸ í™œë™ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateModelActivity(status, progress = 0) {
            const gauge = document.getElementById('activity-gauge');
            const text = document.getElementById('activity-text');
            
            if (!gauge || !text) return;
            
            switch(status) {
                case 'idle':
                    gauge.style.background = 'conic-gradient(#6c757d 0deg, #e9ecef 0deg)';
                    text.textContent = 'ëŒ€ê¸°ì¤‘';
                    text.style.color = '#6c757d';
                    break;
                case 'active':
                    const angle = (progress / 100) * 360;
                    gauge.style.background = `conic-gradient(#28a745 ${angle}deg, #e9ecef ${angle}deg)`;
                    text.textContent = 'í™œì„±';
                    text.style.color = '#28a745';
                    break;
                case 'processing':
                    gauge.style.background = 'conic-gradient(#007bff 0deg, #007bff 90deg, #e9ecef 90deg, #e9ecef 180deg, #007bff 180deg, #007bff 270deg, #e9ecef 270deg)';
                    gauge.style.animation = 'spin 1s linear infinite';
                    text.textContent = 'ì²˜ë¦¬ì¤‘';
                    text.style.color = '#007bff';
                    break;
                case 'error':
                    gauge.style.background = 'conic-gradient(#dc3545 0deg, #e9ecef 0deg)';
                    gauge.style.animation = 'none';
                    text.textContent = 'ì˜¤ë¥˜';
                    text.style.color = '#dc3545';
                    break;
            }
        }
        
        // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateProcessingActivity(status, progress = 0) {
            const gauge = document.getElementById('processing-gauge');
            const text = document.getElementById('processing-text');
            
            if (!gauge || !text) return;
            
            switch(status) {
                case 'idle':
                    gauge.style.background = 'conic-gradient(#6c757d 0deg, #e9ecef 0deg)';
                    gauge.style.animation = 'none';
                    text.textContent = 'ëŒ€ê¸°ì¤‘';
                    text.style.color = '#6c757d';
                    break;
                case 'processing':
                    // ì§„í–‰ë¥ ì´ ì œê³µëœ ê²½ìš° ì§„í–‰ë¥  í‘œì‹œ, ì•„ë‹ˆë©´ ìŠ¤í”¼ë„ˆ ì• ë‹ˆë©”ì´ì…˜
                    if (progress > 0) {
                        const angle = (progress / 100) * 360;
                        gauge.style.background = `conic-gradient(#007bff ${angle}deg, #e9ecef ${angle}deg)`;
                        gauge.style.animation = 'none';
                        text.textContent = `ì²˜ë¦¬ì¤‘ ${Math.round(progress)}%`;
                    } else {
                        gauge.style.background = 'conic-gradient(#007bff 0deg, #007bff 90deg, #e9ecef 90deg, #e9ecef 180deg, #007bff 180deg, #007bff 270deg, #e9ecef 270deg)';
                        gauge.style.animation = 'spin 1s linear infinite';
                        text.textContent = 'ì²˜ë¦¬ì¤‘';
                    }
                    text.style.color = '#007bff';
                    break;
                case 'completed':
                    const angle = (progress / 100) * 360;
                    gauge.style.background = `conic-gradient(#28a745 ${angle}deg, #e9ecef ${angle}deg)`;
                    gauge.style.animation = 'none';
                    text.textContent = 'ì™„ë£Œ';
                    text.style.color = '#28a745';
                    break;
                case 'error':
                    gauge.style.background = 'conic-gradient(#dc3545 0deg, #e9ecef 0deg)';
                    gauge.style.animation = 'none';
                    text.textContent = 'ì˜¤ë¥˜';
                    text.style.color = '#dc3545';
                    break;
            }
        }
        
        // ì‹œìŠ¤í…œ í†µê³„ ì—…ë°ì´íŠ¸
        async function updateSystemStats() {
            try {
                // ë¬¸ì„œ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                const docsRes = await fetch('/api/documents');
                const docsData = await docsRes.json();
                
                // ì €ì¥ì†Œ í†µê³„ ê°€ì ¸ì˜¤ê¸°
                const statsRes = await fetch('/api/storage/stats');
                const statsData = await statsRes.json();
                
                // UI ì—…ë°ì´íŠ¸
                const docCount = docsData.documents ? docsData.documents.length : 0;
                const totalChunks = docsData.documents ? 
                    docsData.documents.reduce((sum, doc) => sum + (doc.chunk_count || 0), 0) : 0;
                
                document.getElementById('doc-count').textContent = docCount;
                document.getElementById('chunk-count').textContent = totalChunks;
                
                if (statsRes.ok && statsData.file_storage) {
                    const sizeMB = Math.round(statsData.file_storage.total_size_mb || 0);
                    document.getElementById('storage-size').textContent = `${sizeMB}MB`;
                }
                
                // ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„
                const now = new Date();
                const timeStr = now.toLocaleTimeString('ko-KR', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                document.getElementById('last-update').textContent = timeStr;
                
            } catch (error) {
                console.error('ì‹œìŠ¤í…œ í†µê³„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
            }
        }
        
        // ë¹ ë¥¸ ì„¤ì • í† ê¸€ ì´ë²¤íŠ¸
        function setupQuickSettings() {
            // OCR êµì • í† ê¸€
            const ocrToggle = document.getElementById('ocr-correction-toggle');
            ocrToggle.addEventListener('change', (e) => {
                console.log('OCR êµì •:', e.target.checked ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”');
                // ì‹¤ì œ ì„¤ì • ë³€ê²½ ë¡œì§ì€ ì—¬ê¸°ì— êµ¬í˜„
            });
            
            // LLM êµì • í† ê¸€
            const llmToggle = document.getElementById('llm-correction-toggle');
            llmToggle.addEventListener('change', (e) => {
                console.log('LLM êµì •:', e.target.checked ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”');
                // ì‹¤ì œ ì„¤ì • ë³€ê²½ ë¡œì§ì€ ì—¬ê¸°ì— êµ¬í˜„
            });
            
            // ìë™ ìƒˆë¡œê³ ì¹¨ í† ê¸€
            const autoRefreshToggle = document.getElementById('auto-refresh-toggle');
            autoRefreshToggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    startDocumentListPolling();
                    updateAutoRefreshIndicator('í™œì„±í™”');
                } else {
                    stopDocumentListPolling();
                    updateAutoRefreshIndicator('ë¹„í™œì„±í™”');
                }
            });
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ Ollama ìƒíƒœ/ëª¨ë¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°ëŠ” ì•„ë˜ DOMContentLoadedì—ì„œ ì²˜ë¦¬

        // í”„ë¡œê·¸ë ˆìŠ¤ë°” ë‹¨ê³„ë³„ ë§¤í•‘
        const progressSteps = [
            { step: 'OCR', percent: 20 },
            { step: 'Chunking', percent: 40 },
            { step: 'Embedding', percent: 60 },
            { step: 'Storing', percent: 80 },
            { step: 'Done', percent: 100 },
            { step: 'Error', percent: 100 },
        ];
        
        // ë‹¤ì¤‘ íŒŒì¼ ì§„í–‰ë¥  ì¶”ì  ë³€ìˆ˜ë“¤
        let multiFileTracking = {
            files: new Map(), // documentId -> {filename, status, interval, startTime}
            intervals: new Set(),
            hideTimeout: null
        };
        
        // ê²½ê³¼ì‹œê°„ í¬ë§·íŒ… í•¨ìˆ˜
        function formatElapsedTime(startTime) {
            if (!startTime) return '';
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // ë‹¤ì¤‘ íŒŒì¼ ì§„í–‰ë¥  ì¶”ì  ì‹œì‘
        function startMultiFileProgressTracking(files) {
            console.log('ë‹¤ì¤‘ íŒŒì¼ ì§„í–‰ë¥  ì¶”ì  ì‹œì‘:', files);
            
            // ì§„í–‰ë¥  ì»¨í…Œì´ë„ˆ í‘œì‹œ
            const progressContainer = document.getElementById('progress-container');
            progressContainer.style.display = 'block';
            
            // ê¸°ì¡´ ë°ì´í„° ì •ë¦¬
            clearMultiFileTracking();
            
            // ì „ì²´ ì§„í–‰ë¥  ì´ˆê¸°í™”
            updateOverallProgress(0, files.length);
            
            // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  UI ìƒì„± ë° ì¶”ì  ì‹œì‘
            files.forEach(file => {
                createIndividualProgressUI(file.documentId, file.filename);
                startIndividualFileTracking(file.documentId, file.filename);
            });
        }
        
        // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  UI ìƒì„± (ë™ì  ìŠ¤íƒ€ì¼)
        function createIndividualProgressUI(documentId, filename) {
            const container = document.getElementById('individual-progress-container');
            
            const fileDiv = document.createElement('div');
            fileDiv.id = `progress-${documentId}`;
            fileDiv.className = 'file-progress-card';
            fileDiv.style.cssText = `
                margin-bottom: 15px; 
                padding: 15px; 
                border: 1px solid #dee2e6; 
                border-radius: 12px; 
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.05);
                transition: all 0.3s ease;
            `;
            
            fileDiv.innerHTML = `
                <!-- íŒŒì¼ í—¤ë” -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div id="file-icon-${documentId}" style="font-size: 1.2em;">ğŸ“„</div>
                        <span style="font-weight: 600; color: #2c3e50; font-size: 1rem;">ë¬¸ì„œ ì²˜ë¦¬ ì¤‘...</span>
                    </div>
                    <div id="status-badge-${documentId}" class="status-badge status-waiting">
                        <span id="status-text-${documentId}">ëŒ€ê¸° ì¤‘</span>
                    </div>
                </div>
                
                <!-- ì²˜ë¦¬ ë‹¨ê³„ í‘œì‹œ (ë™ì ) -->
                <div id="process-steps-${documentId}" class="process-steps-dynamic">
                    <!-- í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ë‹¨ê³„ë§Œ í‘œì‹œë©ë‹ˆë‹¤ -->
                </div>
                
                <!-- ì§„í–‰ë¥  ë°” (ì „ì²´) -->
                <div style="margin-top: 10px;">
                    <div style="height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden;">
                        <div id="progress-bar-${documentId}" style="height: 100%; width: 0%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.3s ease;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.85em; color: #6c757d;">
                        <span id="progress-text-${documentId}">0%</span>
                        <span id="time-info-${documentId}"></span>
                    </div>
                </div>
            `;
            
            container.appendChild(fileDiv);
        }
        
        // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  ì¶”ì 
        function startIndividualFileTracking(documentId, filename) {
            const startTime = Date.now(); // ì²˜ë¦¬ ì‹œì‘ ì‹œê°„ ê¸°ë¡
            
            const interval = setInterval(async () => {
                try {
                    const res = await fetch(`/api/upload_status/${documentId}`);
                    const data = await res.json();
                    
                    updateIndividualProgress(documentId, data);
                    
                    // íŒŒì¼ ìƒíƒœ ì—…ë°ì´íŠ¸ - ë°±ì—”ë“œ percent ê°’ ìš°ì„  ì‚¬ìš©
                    const actualPercent = data.percent !== undefined ? data.percent : (progressSteps.find(s => s.step === data.step) || { percent: 0 }).percent;
                    const fileInfo = multiFileTracking.files.get(documentId) || {};
                    multiFileTracking.files.set(documentId, {
                        ...fileInfo,
                        filename,
                        status: data.step,
                        progress: actualPercent,
                        completed: data.step === 'Done' || data.step === 'Error',
                        startTime: fileInfo.startTime || startTime // ì‹œì‘ ì‹œê°„ ìœ ì§€
                    });
                    
                    // ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì‹¤ì‹œê°„)
                    updateOverallProgressFromFiles();
                    
                    if (data.step === 'Done' || data.step === 'Error') {
                        clearInterval(interval);
                        multiFileTracking.intervals.delete(interval);
                        checkAllFilesCompleted();
                    }
                } catch (error) {
                    console.error(`ì§„í–‰ë¥  ì¶”ì  ì˜¤ë¥˜ (${documentId}):`, error);
                    document.getElementById(`message-${documentId}`).textContent = 'ìƒíƒœ í™•ì¸ ì‹¤íŒ¨';
                }
            }, 1500);
            
            multiFileTracking.intervals.add(interval);
            multiFileTracking.files.set(documentId, {
                filename,
                status: 'processing',
                interval,
                completed: false,
                startTime: startTime // ì‹œì‘ ì‹œê°„ ì €ì¥
            });
        }
        
        // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ë™ì  ìŠ¤íƒ€ì¼)
        function updateIndividualProgress(documentId, data) {
            // ë°±ì—”ë“œ percent ê°’ì„ ìš°ì„  ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ ë‹¨ê³„ë³„ ê°’ ì‚¬ìš©
            const percent = data.percent !== undefined ? data.percent : (progressSteps.find(s => s.step === data.step) || { percent: 0 }).percent;
            
            // ë©”ì¸ UI ìš”ì†Œë“¤
            const fileCard = document.getElementById(`progress-${documentId}`);
            const progressBar = document.getElementById(`progress-bar-${documentId}`);
            const statusBadge = document.getElementById(`status-badge-${documentId}`);
            const statusText = document.getElementById(`status-text-${documentId}`);
            const progressText = document.getElementById(`progress-text-${documentId}`);
            const timeInfo = document.getElementById(`time-info-${documentId}`);
            const fileIcon = document.getElementById(`file-icon-${documentId}`);
            
            // ì§„í–‰ë¥  ë°” ì—…ë°ì´íŠ¸ (ì‹¤ì œ percent ê°’ ì‚¬ìš©, 0-100 ë²”ìœ„ ì œí•œ)
            const displayPercent = Math.max(0, Math.min(100, Math.round(percent)));
            if (progressBar) progressBar.style.width = displayPercent + '%';
            if (progressText) {
                // í˜ì´ì§€ ì •ë³´ê°€ ìˆìœ¼ë©´ ì¶”ê°€ í‘œì‹œ
                if (data.current_page && data.total_pages) {
                    progressText.textContent = `${displayPercent}% (${data.current_page}/${data.total_pages} í˜ì´ì§€)`;
                } else {
                    progressText.textContent = `${displayPercent}%`;
                }
            }
            
            // multiFileTrackingì˜ íŒŒì¼ ì •ë³´ë„ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸
            if (multiFileTracking.files.has(documentId)) {
                const fileInfo = multiFileTracking.files.get(documentId);
                fileInfo.progress = displayPercent;
                fileInfo.status = data.step;
                fileInfo.completed = data.step === 'Done' || data.step === 'Error';
                multiFileTracking.files.set(documentId, fileInfo);
            }
            
            // í”„ë¡œì„¸ìŠ¤ ë‹¨ê³„ ì—…ë°ì´íŠ¸ (ìƒì„¸ ì •ë³´ í¬í•¨)
            updateProcessSteps(documentId, data.step, data);
            
            if (data.step === 'Done') {
                // ì™„ë£Œ ìƒíƒœ
                if (fileCard) {
                    fileCard.className = 'file-progress-card completed';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-completed';
                }
                if (statusText) statusText.textContent = 'ì™„ë£Œ';
                if (fileIcon) fileIcon.textContent = 'âœ…';
                if (progressBar) {
                    progressBar.style.background = 'linear-gradient(90deg, #28a745 0%, #20c997 100%)';
                    progressBar.style.width = '100%';
                }
                if (progressText) progressText.textContent = '100%';
                if (timeInfo) timeInfo.textContent = 'ì™„ë£Œë¨';
                
            } else if (data.step === 'Error') {
                // ì˜¤ë¥˜ ìƒíƒœ
                if (fileCard) {
                    fileCard.className = 'file-progress-card error';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-error';
                }
                if (statusText) statusText.textContent = 'ì˜¤ë¥˜';
                if (fileIcon) fileIcon.textContent = 'âŒ';
                if (progressBar) {
                    progressBar.style.background = 'linear-gradient(90deg, #dc3545 0%, #e74c3c 100%)';
                }
                if (timeInfo) timeInfo.textContent = 'ì˜¤ë¥˜ ë°œìƒ';
                
            } else {
                // ì²˜ë¦¬ ì¤‘ ìƒíƒœ
                if (fileCard) {
                    fileCard.className = 'file-progress-card processing';
                }
                if (statusBadge) {
                    statusBadge.className = 'status-badge status-processing';
                }
                if (statusText) statusText.textContent = 'ì²˜ë¦¬ ì¤‘';
                if (fileIcon) fileIcon.textContent = 'âš™ï¸';
                if (timeInfo) {
                    const fileInfo = multiFileTracking.files.get(documentId);
                    if (fileInfo && fileInfo.startTime) {
                        timeInfo.textContent = formatElapsedTime(fileInfo.startTime);
                    } else {
                        timeInfo.textContent = '00:00';
                    }
                }
            }
        }
        
        // í”„ë¡œì„¸ìŠ¤ ë‹¨ê³„ ì‹œê°í™” ì—…ë°ì´íŠ¸ (ë™ì  ë°©ì‹)
        function updateProcessSteps(documentId, currentStep, data = {}) {
            const processStepsContainer = document.getElementById(`process-steps-${documentId}`);
            if (!processStepsContainer) return;
            
            // ìƒì„¸í•œ ë‹¨ê³„ë³„ í‘œì‹œ ì •ë³´
            let stepText = '';
            let stepIcon = '';
            
            switch(currentStep) {
                case 'Analyzing':
                    stepIcon = 'ğŸ”';
                    stepText = `PDF íŒŒì¼ ë¶„ì„ ì¤‘... ${data.total_pages ? `(${data.total_pages}í˜ì´ì§€)` : ''}`;
                    break;
                case 'OCR':
                    stepIcon = 'ğŸ‘ï¸';
                    if (data.current_page && data.total_pages) {
                        const details = data.details || {};
                        const stage = details.stage || '';
                        let stageText = '';
                        if (stage === 'text') stageText = 'í…ìŠ¤íŠ¸ ì¶”ì¶œ';
                        else if (stage === 'images') stageText = 'ì´ë¯¸ì§€ ì¶”ì¶œ';
                        else if (stage === 'tables') stageText = 'í‘œ ì¶”ì¶œ';
                        else stageText = 'OCR ì²˜ë¦¬';
                        
                        stepText = `${stageText} (${data.current_page}/${data.total_pages} í˜ì´ì§€)`;
                    } else if (data.message) {
                        // ë©”ì‹œì§€ì—ì„œ ì¤‘ë³µ 'ì¤‘...' ì œê±°
                        let cleanMessage = data.message;
                        if (cleanMessage.includes('ì¤‘...') && !cleanMessage.endsWith('ì¤‘...')) {
                            cleanMessage = cleanMessage.replace(/ì¤‘\.\.\./g, '');
                        }
                        stepText = cleanMessage;
                    } else {
                        stepText = 'OCR ì²˜ë¦¬';
                    }
                    break;
                case 'Chunking':
                    stepIcon = 'ğŸ“';
                    if (data.details && data.details.text_length) {
                        stepText = `í…ìŠ¤íŠ¸ ë¶„í•  (${data.details.text_length.toLocaleString()}ì)`;
                    } else if (data.message) {
                        stepText = data.message.replace(/ì¤‘\.\.\./g, '');
                    } else {
                        stepText = 'í…ìŠ¤íŠ¸ ì²­í¬ ë¶„í• ';
                    }
                    break;
                case 'Embedding':
                    stepIcon = 'ğŸ§ ';
                    if (data.details && data.details.chunks_to_process) {
                        stepText = `ì„ë² ë”© ìƒì„± (${data.details.chunks_to_process}ê°œ ì²­í¬)`;
                    } else if (data.message) {
                        stepText = data.message.replace(/ì¤‘\.\.\./g, '');
                    } else {
                        stepText = 'ë²¡í„° ì„ë² ë”© ìƒì„±';
                    }
                    break;
                case 'Storing':
                    stepIcon = 'ğŸ’¾';
                    if (data.details) {
                        const details = data.details;
                        const parts = [];
                        if (details.texts) parts.push(`í…ìŠ¤íŠ¸ ${details.texts}ê°œ`);
                        if (details.images) parts.push(`ì´ë¯¸ì§€ ${details.images}ê°œ`);
                        if (details.tables) parts.push(`í‘œ ${details.tables}ê°œ`);
                        stepText = `ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ (${parts.join(', ')})`;
                    } else if (data.message) {
                        stepText = data.message.replace(/ì¤‘\.\.\./g, '');
                    } else {
                        stepText = 'ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥';
                    }
                    break;
                case 'Done':
                    stepIcon = 'âœ…';
                    if (data.details) {
                        const details = data.details;
                        stepText = `ì²˜ë¦¬ ì™„ë£Œ (${details.total_pages || 0}í˜ì´ì§€, ${details.text_chunks || 0}ì²­í¬, ${details.images || 0}ì´ë¯¸ì§€, ${details.tables || 0}í‘œ)`;
                    } else if (data.message) {
                        stepText = data.message;
                    } else {
                        stepText = 'ëª¨ë“  ì²˜ë¦¬ ì™„ë£Œ';
                    }
                    break;
                case 'Error':
                    stepIcon = 'âŒ';
                    stepText = data.message || 'ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
                    break;
                default:
                    stepIcon = 'â³';
                    stepText = data.message || 'ì¤€ë¹„ ì¤‘...';
            }
            
            // ìƒíƒœë³„ CSS í´ë˜ìŠ¤ ê²°ì •
            let statusClass = 'waiting';
            if (currentStep === 'Done') {
                statusClass = 'completed';
            } else if (currentStep === 'Error') {
                statusClass = 'error';
            } else if (['Analyzing', 'OCR', 'Chunking', 'Embedding', 'Storing'].includes(currentStep)) {
                statusClass = 'processing';
            }
            
            // ê²½ê³¼ì‹œê°„ ì¶”ê°€ (ì˜µì…˜)
            const fileInfo = multiFileTracking.files.get(documentId);
            const elapsedTime = (fileInfo && fileInfo.startTime) ? formatElapsedTime(fileInfo.startTime) : '';
            
            // í•œ ì¤„ ê¹”ë”í•œ ë‹¨ê³„ í‘œì‹œ
            const compactDetails = getCompactDetails(data.details || {});
            const fullText = compactDetails ? `${stepText} ${compactDetails}` : stepText;
            
            processStepsContainer.innerHTML = `
                <div class="current-step-display ${statusClass} compact">
                    <div class="step-icon ${statusClass}">${stepIcon}</div>
                    <div class="step-text-compact">
                        <span class="main-text">${fullText}</span>
                        ${elapsedTime ? `<span class="elapsed-time">${elapsedTime}</span>` : ''}
                    </div>
                </div>
            `;
        }
        
        // í•œ ì¤„ ì••ì¶• ìƒì„¸ ì •ë³´ ìƒì„±
        function getCompactDetails(details) {
            const compactItems = [];
            
            // ì¤‘ë³µ ì •ë³´ ë°©ì§€ë¥¼ ìœ„í•´ ìš°ì„ ìˆœìœ„ë³„ë¡œ í‘œì‹œ
            if (details.text_length && details.chunks_created) {
                compactItems.push(`${details.text_length.toLocaleString()}ì â†’ ${details.chunks_created}ì²­í¬`);
            } else if (details.text_length) {
                compactItems.push(`${details.text_length.toLocaleString()}ì`);
            } else if (details.chunks_created) {
                compactItems.push(`${details.chunks_created}ì²­í¬`);
            }
            
            if (details.embeddings_created) {
                compactItems.push(`${details.embeddings_created}ì„ë² ë”©`);
            }
            
            if (details.stored_texts || details.stored_images || details.stored_tables) {
                const counts = [];
                if (details.stored_texts) counts.push(`í…ìŠ¤íŠ¸${details.stored_texts}`);
                if (details.stored_images) counts.push(`ì´ë¯¸ì§€${details.stored_images}`);
                if (details.stored_tables) counts.push(`í‘œ${details.stored_tables}`);
                if (counts.length > 0) {
                    compactItems.push(counts.join(' â€¢ '));
                }
            }
            
            return compactItems.length > 0 ? ` â€¢ ${compactItems.join(' â€¢ ')}` : '';
        }
        
        // ìƒì„¸ ì •ë³´ë¥¼ í¬ë§·íŒ…í•˜ì—¬ í‘œì‹œ (ë ˆê±°ì‹œ - ì‚¬ìš©ì•ˆí•¨)
        function getFormattedDetails(details) {
            const items = [];
            
            if (details.stage) {
                const stageNames = {
                    'text': 'í…ìŠ¤íŠ¸ ì¶”ì¶œ',
                    'images': 'ì´ë¯¸ì§€ ì¶”ì¶œ', 
                    'tables': 'í‘œ ì¶”ì¶œ'
                };
                items.push(`ì²˜ë¦¬ ë‹¨ê³„: ${stageNames[details.stage] || details.stage}`);
            }
            
            if (details.pages_processed !== undefined) {
                items.push(`ì²˜ë¦¬ëœ í˜ì´ì§€: ${details.pages_processed}ê°œ`);
            }
            
            if (details.text_length !== undefined) {
                items.push(`í…ìŠ¤íŠ¸ ê¸¸ì´: ${details.text_length.toLocaleString()}ì`);
            }
            
            if (details.chunks_created !== undefined) {
                items.push(`ìƒì„±ëœ ì²­í¬: ${details.chunks_created}ê°œ`);
            }
            
            if (details.embeddings_created !== undefined) {
                items.push(`ìƒì„±ëœ ì„ë² ë”©: ${details.embeddings_created}ê°œ`);
            }
            
            if (details.embedding_dimension !== undefined) {
                items.push(`ë²¡í„° ì°¨ì›: ${details.embedding_dimension}ì°¨ì›`);
            }
            
            return items.map(item => `<div class="detail-item">â€¢ ${item}</div>`).join('');
        }
        
        // ì‚¬ìš©ì ì¹œí™”ì  ë©”ì‹œì§€ ìƒì„±
        function getFriendlyMessage(step, originalMessage) {
            const friendlyMessages = {
                'OCR': 'ğŸ‘ï¸ OCRë¡œ í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                'Chunking': 'ğŸ“ í…ìŠ¤íŠ¸ë¥¼ ì²­í¬ë¡œ ë¶„í• í•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                'Embedding': 'ğŸ§  ì„ë² ë”© ë²¡í„°ë¥¼ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                'Storing': 'ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                'Done': 'âœ… ëª¨ë“  ì²˜ë¦¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!'
            };
            
            return friendlyMessages[step] || originalMessage || 'ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...';
        }
        
        // ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì™„ë£Œ ê°œìˆ˜ ê¸°ë°˜)
        function updateOverallProgress(completedCount, totalCount) {
            const progressBar = document.getElementById('overall-progress-bar');
            const countSpan = document.getElementById('overall-progress-count');
            const textSpan = document.getElementById('overall-progress-text');
            
            const percentage = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;
            
            if (progressBar) progressBar.style.width = percentage + '%';
            if (countSpan) countSpan.textContent = `${completedCount}/${totalCount} ì™„ë£Œ`;
            if (textSpan) {
                if (completedCount === totalCount && totalCount > 0) {
                    textSpan.textContent = 'âœ… ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ';
                    progressBar.style.background = '#28a745';
                } else {
                    textSpan.textContent = 'ì „ì²´ ì§„í–‰ë¥ ';
                    progressBar.style.background = '#28a745';
                }
            }
        }
        
        // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥  ê¸°ë°˜ ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì‹¤ì‹œê°„)
        function updateOverallProgressFromFiles() {
            const progressBar = document.getElementById('overall-progress-bar');
            const countSpan = document.getElementById('overall-progress-count');
            const textSpan = document.getElementById('overall-progress-text');
            
            const files = Array.from(multiFileTracking.files.values());
            if (files.length === 0) return;
            
            // ê°œë³„ íŒŒì¼ ì§„í–‰ë¥ ì˜ ê°€ì¤‘ í‰ê·  ê³„ì‚° (ì‹¤ì œ ì§„í–‰ë¥  ë°˜ì˜)
            const totalProgress = files.reduce((sum, file) => {
                // progress ê°’ì´ ìœ íš¨í•œì§€ í™•ì¸í•˜ê³  0-100 ë²”ìœ„ë¡œ ì œí•œ
                const fileProgress = Math.max(0, Math.min(100, file.progress || 0));
                return sum + fileProgress;
            }, 0);
            const averageProgress = Math.round(totalProgress / files.length);
            
            // ì™„ë£Œëœ íŒŒì¼ ê°œìˆ˜
            const completedFiles = files.filter(f => f.completed);
            const completedCount = completedFiles.length;
            const totalCount = files.length;
            
            // ì§„í–‰ë¥  ë°” ì—…ë°ì´íŠ¸ (í‰ê·  ì§„í–‰ë¥  ê¸°ë°˜, ì™„ë£Œ ìƒíƒœ ê³ ë ¤)
            let displayProgress = averageProgress;
            
            // ëª¨ë“  íŒŒì¼ì´ ì™„ë£Œë˜ë©´ 100%ë¡œ ì„¤ì •
            if (completedCount === totalCount && totalCount > 0) {
                displayProgress = 100;
            }
            
            if (progressBar) progressBar.style.width = displayProgress + '%';
            if (countSpan) countSpan.textContent = `${completedCount}/${totalCount} ì™„ë£Œ`;
            if (textSpan) {
                if (completedCount === totalCount && totalCount > 0) {
                    textSpan.textContent = 'âœ… ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ';
                    if (progressBar) progressBar.style.background = '#28a745';
                } else {
                    textSpan.textContent = `ì „ì²´ ì§„í–‰ë¥  (${displayProgress}%)`;
                    if (progressBar) progressBar.style.background = '#007bff';
                    // ì‹¤ì‹œê°„ ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì²˜ë¦¬ ì¤‘, ì§„í–‰ë¥  ë°˜ì˜)
                    if (totalCount > 0) {
                        updateProcessingActivity('processing', displayProgress);
                    }
                }
            }
            
            // ë””ë²„ê¹… ë¡œê·¸ (ê°œë°œ ì‹œì—ë§Œ ì‚¬ìš©)
            console.log(`ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸: ${displayProgress}% (ì™„ë£Œ: ${completedCount}/${totalCount})`);
        }
        
        // ëª¨ë“  íŒŒì¼ ì™„ë£Œ í™•ì¸
        function checkAllFilesCompleted() {
            const files = Array.from(multiFileTracking.files.values());
            const completedFiles = files.filter(f => f.completed);
            const totalFiles = files.length;
            
            updateOverallProgress(completedFiles.length, totalFiles);
            
            if (completedFiles.length === totalFiles && totalFiles > 0) {
                console.log('ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ!');
                
                // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ì™„ë£Œ'ë¡œ ë³€ê²½ (100% ì§„í–‰ë¥ )
                updateProcessingActivity('completed', 100);
                
                // ë¬¸ì„œ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                setTimeout(() => {
                    fetchDocumentList();
                    console.log('ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ: ë¬¸ì„œ ëª©ë¡ ìë™ ìƒˆë¡œê³ ì¹¨');
                }, 1000);
                
                // ìë™ ìˆ¨ê¹€ ì„¤ì • í™•ì¸
                const autoHide = document.getElementById('auto-hide-progress');
                if (autoHide && autoHide.checked) {
                    scheduleProgressHide();
                }
            }
        }
        
        // ì§„í–‰ë¥  ì°½ ìë™ ìˆ¨ê¹€ ì˜ˆì•½
        function scheduleProgressHide() {
            if (multiFileTracking.hideTimeout) {
                clearTimeout(multiFileTracking.hideTimeout);
            }
            
            multiFileTracking.hideTimeout = setTimeout(() => {
                const progressContainer = document.getElementById('progress-container');
                const selectedFilesContainer = document.getElementById('selected-files-container');
                
                if (progressContainer) {
                    progressContainer.style.display = 'none';
                    clearMultiFileTracking();
                    // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœë¥¼ 'ëŒ€ê¸°ì¤‘'ìœ¼ë¡œ ë³µê·€
                    updateProcessingActivity('idle');
                }
                
                // ì„ íƒëœ íŒŒì¼ ëª©ë¡ë„ ìˆ¨ê¸°ê³  ì´ˆê¸°í™”
                if (selectedFilesContainer) {
                    selectedFilesContainer.style.display = 'none';
                    document.getElementById('selected-files-list').innerHTML = '';
                    selectedFilesForUpload.clear();
                    
                    // íŒŒì¼ ì…ë ¥ ì´ˆê¸°í™”
                    const pdfFileInput = document.getElementById('pdf-file');
                    if (pdfFileInput) {
                        pdfFileInput.value = '';
                    }
                    
                    // ì—…ë¡œë“œ ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
                    updateSelectedCount();
                }
            }, 10000); // 10ì´ˆ í›„ ìˆ¨ê¹€
        }
        
        // ë‹¤ì¤‘ íŒŒì¼ ì¶”ì  ì •ë¦¬
        function clearMultiFileTracking() {
            // ëª¨ë“  ì¸í„°ë²Œ ì •ë¦¬
            multiFileTracking.intervals.forEach(interval => clearInterval(interval));
            multiFileTracking.intervals.clear();
            
            // ìˆ¨ê¹€ íƒ€ì´ë¨¸ ì •ë¦¬
            if (multiFileTracking.hideTimeout) {
                clearTimeout(multiFileTracking.hideTimeout);
                multiFileTracking.hideTimeout = null;
            }
            
            // íŒŒì¼ ë°ì´í„° ì •ë¦¬
            multiFileTracking.files.clear();
            
            // ê°œë³„ ì§„í–‰ë¥  UI ì •ë¦¬
            const container = document.getElementById('individual-progress-container');
            if (container) container.innerHTML = '';
        }
        
        // ê¸°ì¡´ ë‹¨ì¼ íŒŒì¼ ì§„í–‰ë¥  í•¨ìˆ˜ (í•˜ìœ„ í˜¸í™˜ì„±)
        function startProgressPolling(documentId) {
            const progressContainer = document.getElementById('progress-container');
            const progressBarInner = document.getElementById('progress-bar-inner');
            const progressMessage = document.getElementById('progress-message');
            progressContainer.style.display = 'block';
            progressBarInner.style.width = '0%';
            progressMessage.textContent = 'ì²˜ë¦¬ ëŒ€ê¸° ì¤‘...';
            if(progressInterval) clearInterval(progressInterval);
            progressInterval = setInterval(async () => {
                try {
                    const res = await fetch(`/api/upload_status/${documentId}`);
                    const data = await res.json();
                    const stepInfo = progressSteps.find(s => s.step === data.step) || { percent: 0 };
                    progressBarInner.style.width = stepInfo.percent + '%';
                    progressMessage.textContent = data.message || '';
                    if(data.step === 'Done') {
                        progressMessage.textContent = 'âœ… ' + data.message;
                        clearInterval(progressInterval);
                        // ì²˜ë¦¬ ì™„ë£Œ ì‹œ ë¬¸ì„œ ëª©ë¡ ìë™ ìƒˆë¡œê³ ì¹¨
                        setTimeout(() => {
                            fetchDocumentList();
                            console.log('ë¬¸ì„œ ì²˜ë¦¬ ì™„ë£Œ: ë¬¸ì„œ ëª©ë¡ ìë™ ìƒˆë¡œê³ ì¹¨');
                        }, 1000);
                    } else if(data.step === 'Error') {
                        progressMessage.textContent = 'âŒ ' + data.message;
                        progressBarInner.style.background = '#dc3545';
                        clearInterval(progressInterval);
                    }
                } catch (e) {
                    progressMessage.textContent = 'ìƒíƒœ í™•ì¸ ì‹¤íŒ¨';
                }
            }, 1500);
        }

        // ë¬¸ì„œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ë° ë“œë¡­ë‹¤ìš´ ê°±ì‹ 
        async function fetchDocumentList() {
            try {
                const res = await fetch('/api/documents');
                const data = await res.json();
                
                // ì±„íŒ…ìš© ë¬¸ì„œ ì²´í¬ë°•ìŠ¤ ì—…ë°ì´íŠ¸
                const info = document.getElementById('document-info');
                const selectAllCheckbox = document.getElementById('select-all-docs');
                const individualDocCheckboxes = document.getElementById('individual-doc-checkboxes');
                const documentList = document.getElementById('document-list');
                
                if (!individualDocCheckboxes || !documentList) {
                    console.error('Required DOM elements not found');
                    return;
                }
                
                individualDocCheckboxes.innerHTML = '';
                documentList.innerHTML = '';
                
                // ê¸°ë³¸ ì „ì²´ ë¬¸ì„œ ì„ íƒ
                if (selectAllCheckbox) {
                    selectAllCheckbox.checked = true;
                }
                
                // ê°œë³„ ë¬¸ì„œ ì²´í¬ë°•ìŠ¤ ìƒì„± (ìƒˆë¡œìš´ ìœ„ì¹˜ì—)
                if (data.documents && data.documents.length > 0) {
                    data.documents.forEach(doc => {
                        // ì±„íŒ…ìš© ì²´í¬ë°•ìŠ¤ (ìƒˆë¡œìš´ êµ¬ì¡°)
                        const div = document.createElement('div');
                        div.style.cssText = 'margin-bottom: 6px; display: flex; align-items: center; gap: 8px; padding: 4px 8px; border-radius: 4px; transition: background-color 0.2s;';
                        div.innerHTML = `
                            <input type="checkbox" id="doc-checkbox-${doc.document_id}" value="${doc.document_id}" data-preview="${doc.first_chunk_preview || ''}" style="margin: 0; transform: scale(0.9);">
                            <label for="doc-checkbox-${doc.document_id}" style="font-size: 0.85em; color: #495057; cursor: pointer; flex: 1; margin: 0;">
                                ğŸ“„ ${doc.document_id} <span style="color: #6c757d;">(${doc.chunk_count}ì²­í¬)</span>
                            </label>
                        `;
                        
                        // í˜¸ë²„ íš¨ê³¼
                        div.addEventListener('mouseenter', () => {
                            div.style.backgroundColor = '#f8f9fa';
                        });
                        div.addEventListener('mouseleave', () => {
                            div.style.backgroundColor = 'transparent';
                        });
                        
                        individualDocCheckboxes.appendChild(div);
                        
                        // ë¬¸ì„œ ê´€ë¦¬ ëª©ë¡
                        const docDiv = document.createElement('div');
                        docDiv.className = 'document-item';
                        docDiv.innerHTML = `
                            <div class="document-info">
                                <div class="document-title">ğŸ“„ ${doc.document_id}</div>
                                <div class="text-muted">${doc.chunk_count} ì²­í¬</div>
                                <div class="document-preview">
                                    ${doc.first_chunk_preview ? doc.first_chunk_preview.slice(0, 100) + '...' : 'ë¯¸ë¦¬ë³´ê¸° ì—†ìŒ'}
                                </div>
                            </div>
                            <div class="document-actions">
                                <button onclick="deleteDocument('${doc.document_id}')" class="btn btn-danger" style="padding: 6px 12px; font-size: 0.9rem;">
                                    ğŸ—‘ï¸ ì‚­ì œ
                                </button>
                            </div>
                        `;
                        documentList.appendChild(docDiv);
                    });
                    
                    // ì²« ë¬¸ì„œ ì •ë³´ í‘œì‹œ
                    if (info) {
                        info.textContent = data.documents[0].first_chunk_preview ? 
                            `ë¯¸ë¦¬ë³´ê¸°: ${data.documents[0].first_chunk_preview.slice(0, 60)}...` : '';
                    }
                    
                    // í´ë§ìš© ë¬¸ì„œ ê°œìˆ˜ ì—…ë°ì´íŠ¸
                    lastDocumentCount = data.documents.length;
                } else {
                    if (info) info.textContent = '';
                    documentList.innerHTML = '<div class="text-center text-muted">ğŸ“­ ì €ì¥ëœ ë¬¸ì„œê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                    lastDocumentCount = 0;
                }
                
                // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡
                if (selectAllCheckbox) {
                    selectAllCheckbox.addEventListener('change', () => {
                        const checked = selectAllCheckbox.checked;
                        const boxes = individualDocCheckboxes.querySelectorAll('input[type="checkbox"]');
                        boxes.forEach(cb => { 
                            cb.disabled = checked; 
                            if (checked) cb.checked = false; 
                        });
                        updateChatPreview();
                    });
                }
                
                individualDocCheckboxes.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.addEventListener('change', updateChatPreview);
                });
                
            } catch (e) {
                console.error('ë¬¸ì„œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', e);
                const documentList = document.getElementById('document-list');
                if (documentList) {
                    documentList.innerHTML = '<div class="status-message status-error">âŒ ë¬¸ì„œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨</div>';
                }
                if (document.getElementById('document-info')) {
                    document.getElementById('document-info').textContent = '';
                }
            }
        }
        // ì±—ë´‡ìš© ë¬¸ì„œ ì„ íƒ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
        function updateChatPreview() {
            const info = document.getElementById('document-info');
            const selectAll = document.getElementById('select-all-docs').checked;
            if (selectAll) {
                info.textContent = '';
                return;
            }
            const checked = Array.from(
                document.querySelectorAll('#individual-doc-checkboxes input[type="checkbox"]:checked')
            );
            const previews = checked.map(cb => cb.getAttribute('data-preview')).filter(Boolean);
            info.textContent = previews.length > 0
                ? `ë¯¸ë¦¬ë³´ê¸°: ${previews.map(p => p.slice(0, 60)).join(' | ')}...`
                : '';
        }
        // ì„ íƒëœ ë¬¸ì„œ ID ë°°ì—´ ë°˜í™˜ (ë¹ˆ ë°°ì—´ì€ ì „ì²´ ë¬¸ì„œ ì˜ë¯¸)
        // ë¬¸ì„œ ì„ íƒ UI ìƒí˜¸ì‘ìš© ì„¤ì •
        function setupDocumentSelectionInteraction() {
            const selectAllCheckbox = document.getElementById('select-all-docs');
            const specificDocSection = document.getElementById('specific-doc-section');
            const selectSpecificCheckbox = document.getElementById('select-specific-docs');
            const individualDocContainer = document.getElementById('individual-doc-container');

            console.log('Document selection interaction setup:', {
                selectAllCheckbox: !!selectAllCheckbox,
                specificDocSection: !!specificDocSection,
                selectSpecificCheckbox: !!selectSpecificCheckbox,
                individualDocContainer: !!individualDocContainer
            });

            if (!selectAllCheckbox || !specificDocSection || !selectSpecificCheckbox || !individualDocContainer) {
                console.error('Some document selection elements are missing');
                return;
            }

            // ì „ì²´ ë¬¸ì„œ ì„ íƒ ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸
            selectAllCheckbox.addEventListener('change', function() {
                console.log('ì „ì²´ ë¬¸ì„œ ì„ íƒ ë³€ê²½:', this.checked);
                if (this.checked) {
                    // ì „ì²´ ì„ íƒ ì‹œ íŠ¹ì • ë¬¸ì„œ ì„ íƒ ì„¹ì…˜ ìˆ¨ê¸°ê¸°
                    specificDocSection.style.display = 'none';
                    selectSpecificCheckbox.checked = false;
                    individualDocContainer.style.display = 'none';
                } else {
                    // ì „ì²´ ì„ íƒ í•´ì œ ì‹œ íŠ¹ì • ë¬¸ì„œ ì„ íƒ ì„¹ì…˜ê³¼ ê°œë³„ ë¬¸ì„œ ë¦¬ìŠ¤íŠ¸ ë°”ë¡œ í‘œì‹œ
                    specificDocSection.style.display = 'block';
                    selectSpecificCheckbox.checked = true;
                    individualDocContainer.style.display = 'block';
                    console.log('ê°œë³„ ë¬¸ì„œ ë¦¬ìŠ¤íŠ¸ ìë™ í‘œì‹œë¨');
                }
            });

            // íŠ¹ì • ë¬¸ì„œ ì„ íƒ ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸
            selectSpecificCheckbox.addEventListener('change', function() {
                console.log('íŠ¹ì • ë¬¸ì„œ ì„ íƒ ë³€ê²½:', this.checked);
                if (this.checked) {
                    // íŠ¹ì • ë¬¸ì„œ ì„ íƒ ì‹œ ì „ì²´ ì„ íƒ í•´ì œí•˜ê³  ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
                    selectAllCheckbox.checked = false;
                    individualDocContainer.style.display = 'block';
                    console.log('ê°œë³„ ë¬¸ì„œ ë¦¬ìŠ¤íŠ¸ í‘œì‹œë¨');
                } else {
                    // íŠ¹ì • ë¬¸ì„œ ì„ íƒ í•´ì œ ì‹œ ë¦¬ìŠ¤íŠ¸ ìˆ¨ê¸°ê¸°
                    individualDocContainer.style.display = 'none';
                    // ì•„ë¬´ê²ƒë„ ì„ íƒë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì „ì²´ ì„ íƒìœ¼ë¡œ ë³µê·€
                    selectAllCheckbox.checked = true;
                    specificDocSection.style.display = 'none';
                    console.log('ê°œë³„ ë¬¸ì„œ ë¦¬ìŠ¤íŠ¸ ìˆ¨ê¹€');
                }
            });
        }

        function getSelectedDocumentIds() {
            const selectAll = document.getElementById('select-all-docs').checked;
            if (selectAll) return [];
            const checked = document.querySelectorAll('#individual-doc-checkboxes input[type="checkbox"]:checked');
            return Array.from(checked).map(cb => cb.value);
        }

        // ë¬¸ì„œ ê´€ë¦¬ ê¸°ëŠ¥ë“¤
        async function deleteDocument(documentId) {
            if (!confirm(`ë¬¸ì„œ "${documentId}"ë¥¼ ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                return;
            }
            
            // ê¸°ì¡´ ë©”ì‹œì§€ í´ë¦¬ì–´
            clearManagementStatus();
            
            try {
                const response = await fetch(`/api/documents/${documentId}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                
                if (response.ok) {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `âœ… ë¬¸ì„œ "${documentId}" ì‚­ì œ ì™„ë£Œ`;
                    statusEl.className = 'status-message status-success';
                    fetchDocumentList(); // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    
                    // ì„±ê³µ ë©”ì‹œì§€ë¥¼ 3ì´ˆ í›„ ìë™ìœ¼ë¡œ ìˆ¨ê¹€
                    setTimeout(() => {
                        clearManagementStatus();
                    }, 3000);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `âŒ ì‚­ì œ ì‹¤íŒ¨: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        // ë©”ì‹œì§€ í´ë¦¬ì–´ í—¬í¼ í•¨ìˆ˜
        function clearManagementStatus() {
            const statusEl = document.getElementById('management-status');
            statusEl.textContent = '';
            statusEl.className = 'status-message';
        }

        async function deleteAllDocuments() {
            if (!confirm('ëª¨ë“  ë¬¸ì„œë¥¼ ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) {
                return;
            }
            
            // ê¸°ì¡´ ë©”ì‹œì§€ í´ë¦¬ì–´
            clearManagementStatus();
            
            try {
                const response = await fetch('/api/documents', {
                    method: 'DELETE'
                });
                const result = await response.json();
                
                if (response.ok) {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = 
                        `âœ… ëª¨ë“  ë¬¸ì„œ ì‚­ì œ ì™„ë£Œ (ë¬¸ì„œ: ${result.deleted_documents_count}ê°œ, íŒŒì¼: ${result.deleted_files_count}ê°œ)`;
                    statusEl.className = 'status-message status-success';
                    fetchDocumentList(); // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    
                    // ì„±ê³µ ë©”ì‹œì§€ë¥¼ 5ì´ˆ í›„ ìë™ìœ¼ë¡œ ìˆ¨ê¹€
                    setTimeout(() => {
                        clearManagementStatus();
                    }, 5000);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `âŒ ì‚­ì œ ì‹¤íŒ¨: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        async function showStorageStats() {
            try {
                const response = await fetch('/api/storage/stats');
                const result = await response.json();
                
                if (response.ok) {
                    const stats = `ğŸ“Š ì €ì¥ì†Œ í†µê³„:\n` +
                        `íŒŒì¼: ${result.file_storage.total_files}ê°œ (${result.file_storage.total_size_mb}MB)\n` +
                        `ë¬¸ì„œ: ${result.vector_db.total_documents}ê°œ\n` +
                        `ì²­í¬: ${result.vector_db.total_chunks}ê°œ`;
                    alert(stats);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `âŒ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        async function cleanupOrphanedFiles() {
            if (!confirm('ê³ ì•„ íŒŒì¼ë“¤ì„ ì •ë¦¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }
            
            // ê¸°ì¡´ ë©”ì‹œì§€ í´ë¦¬ì–´
            clearManagementStatus();
            
            try {
                const response = await fetch('/api/documents/cleanup', {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (response.ok) {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = 
                        `âœ… ì •ë¦¬ ì™„ë£Œ: ${result.cleaned_files_count}ê°œ íŒŒì¼ ì •ë¦¬ë¨`;
                    statusEl.className = 'status-message status-success';
                    fetchDocumentList(); // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    
                    // ì„±ê³µ ë©”ì‹œì§€ë¥¼ 4ì´ˆ í›„ ìë™ìœ¼ë¡œ ìˆ¨ê¹€
                    setTimeout(() => {
                        clearManagementStatus();
                    }, 4000);
                } else {
                    const statusEl = document.getElementById('management-status');
                    statusEl.textContent = `âŒ ì •ë¦¬ ì‹¤íŒ¨: ${result.detail}`;
                    statusEl.className = 'status-message status-error';
                }
            } catch (error) {
                const statusEl = document.getElementById('management-status');
                statusEl.textContent = `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`;
                statusEl.className = 'status-message status-error';
            }
        }
        
        // ë¬¸ì„œ ëª©ë¡ ìë™ ìƒˆë¡œê³ ì¹¨ ê°„ê²© (30ì´ˆ)
        let documentListInterval = null;
        let lastDocumentCount = 0;
        
        function startDocumentListPolling() {
            // ê¸°ì¡´ ì¸í„°ë²Œ ì •ë¦¬
            if (documentListInterval) {
                clearInterval(documentListInterval);
            }
            
            // 30ì´ˆë§ˆë‹¤ ë¬¸ì„œ ëª©ë¡ í™•ì¸
            documentListInterval = setInterval(async () => {
                try {
                    const res = await fetch('/api/documents');
                    const data = await res.json();
                    const currentDocumentCount = data.documents ? data.documents.length : 0;
                    
                    // ë¬¸ì„œ ê°œìˆ˜ê°€ ë³€ê²½ë˜ì—ˆìœ¼ë©´ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    if (currentDocumentCount !== lastDocumentCount) {
                        console.log(`ë¬¸ì„œ ê°œìˆ˜ ë³€ê²½ ê°ì§€: ${lastDocumentCount} â†’ ${currentDocumentCount}`);
                        fetchDocumentList();
                        lastDocumentCount = currentDocumentCount;
                        
                        // ìë™ ìƒˆë¡œê³ ì¹¨ í‘œì‹œê¸° ì—…ë°ì´íŠ¸
                        updateAutoRefreshIndicator('ë³€ê²½ ê°ì§€ë¨');
                    }
                } catch (error) {
                    console.log('ë¬¸ì„œ ëª©ë¡ í´ë§ ì˜¤ë¥˜:', error);
                }
            }, 30000); // 30ì´ˆ ê°„ê²©
        }
        
        function stopDocumentListPolling() {
            if (documentListInterval) {
                clearInterval(documentListInterval);
                documentListInterval = null;
            }
        }
        
        function updateAutoRefreshIndicator(status) {
            const indicator = document.getElementById('auto-refresh-indicator');
            if (!indicator) return;
            
            const timestamp = new Date().toLocaleTimeString();
            
            switch(status) {
                case 'ë³€ê²½ ê°ì§€ë¨':
                    indicator.innerHTML = `ğŸ”„ ëª©ë¡ ì—…ë°ì´íŠ¸ë¨ (${timestamp})`;
                    indicator.style.color = '#28a745';
                    setTimeout(() => {
                        indicator.innerHTML = 'ğŸ”„ ìë™ ìƒˆë¡œê³ ì¹¨ í™œì„±í™”';
                        indicator.style.color = '#28a745';
                    }, 3000);
                    break;
                case 'í™œì„±í™”':
                    indicator.innerHTML = 'ğŸ”„ ìë™ ìƒˆë¡œê³ ì¹¨ í™œì„±í™”';
                    indicator.style.color = '#28a745';
                    break;
                case 'ë¹„í™œì„±í™”':
                    indicator.innerHTML = 'â¸ï¸ ìë™ ìƒˆë¡œê³ ì¹¨ ë¹„í™œì„±í™”';
                    indicator.style.color = '#6c757d';
                    break;
                default:
                    indicator.innerHTML = `ğŸ”„ ${status}`;
                    indicator.style.color = '#17a2b8';
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        document.addEventListener('DOMContentLoaded', () => {
            fetchOllamaStatusAndModels();
            fetchDocumentList();
            updateSystemStats(); // ìƒˆë¡œ ì¶”ê°€: ì‹œìŠ¤í…œ í†µê³„ ì´ˆê¸°í™”
            setupQuickSettings(); // ìƒˆë¡œ ì¶”ê°€: ë¹ ë¥¸ ì„¤ì • í† ê¸€ ì´ˆê¸°í™”
            setupDocumentSelectionInteraction(); // ë¬¸ì„œ ì„ íƒ UI ìƒí˜¸ì‘ìš© ì„¤ì •
            
            // ë¬¸ì„œ ì²˜ë¦¬ ìƒíƒœ ì´ˆê¸°í™”
            updateProcessingActivity('idle');
            
            // ë¬¸ì„œ ëª©ë¡ ìë™ ìƒˆë¡œê³ ì¹¨ ì‹œì‘
            startDocumentListPolling();
            updateAutoRefreshIndicator('í™œì„±í™”');
            
            // ë¬¸ì„œ ê´€ë¦¬ ë²„íŠ¼ë“¤
            document.getElementById('refresh-documents').addEventListener('click', fetchDocumentList);
            document.getElementById('storage-stats').addEventListener('click', showStorageStats);
            document.getElementById('cleanup-files').addEventListener('click', cleanupOrphanedFiles);
            document.getElementById('delete-all-documents').addEventListener('click', deleteAllDocuments);
            
            // ì§„í–‰ë¥  ì°½ ë‹«ê¸° ë²„íŠ¼
            document.getElementById('hide-progress').addEventListener('click', () => {
                const progressContainer = document.getElementById('progress-container');
                const selectedFilesContainer = document.getElementById('selected-files-container');
                
                progressContainer.style.display = 'none';
                clearMultiFileTracking();
                
                // ì„ íƒëœ íŒŒì¼ ëª©ë¡ë„ ìˆ¨ê¸°ê³  ì´ˆê¸°í™”
                if (selectedFilesContainer) {
                    selectedFilesContainer.style.display = 'none';
                    document.getElementById('selected-files-list').innerHTML = '';
                    selectedFilesForUpload.clear();
                    
                    // íŒŒì¼ ì…ë ¥ ì´ˆê¸°í™”
                    const pdfFileInput = document.getElementById('pdf-file');
                    if (pdfFileInput) {
                        pdfFileInput.value = '';
                    }
                    
                    // ì—…ë¡œë“œ ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
                    updateSelectedCount();
                }
            });
            
            
            // ëª¨ë¸ ì„ íƒ ë³€ê²½ ì‹œ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
            const modelSelect = document.getElementById('ollama-models');
            modelSelect.addEventListener('change', updateSelectedModelDisplay);
        });

        // ì´ë¯¸ì§€ ëª¨ë‹¬ ê¸°ëŠ¥ ì„ì‹œ ë¹„í™œì„±í™”
        // Image modal functionality temporarily disabled
        
        // í‘œ í™•ì¥/ì¶•ì†Œ ê¸°ëŠ¥
        function toggleTableExpand(tableId) {
            const table = document.getElementById(tableId);
            const hiddenRows = table.querySelectorAll('.hidden-row');
            const expandIndicator = table.querySelector('.table-expand-indicator');
            const button = table.parentElement.querySelector('.btn-small');
            
            if (table.classList.contains('collapsed')) {
                // í™•ì¥
                hiddenRows.forEach(row => row.style.display = '');
                if (expandIndicator) expandIndicator.style.display = 'none';
                button.textContent = 'ì¶•ì†Œí•˜ê¸°';
                table.classList.remove('collapsed');
            } else {
                // ì¶•ì†Œ
                hiddenRows.forEach(row => row.style.display = 'none');
                if (expandIndicator) expandIndicator.style.display = '';
                button.textContent = 'ì „ì²´ ë³´ê¸°';
                table.classList.add('collapsed');
            }
        }
        
        // ESC í‚¤ ì´ë²¤íŠ¸ (ì´ë¯¸ì§€ ëª¨ë‹¬ ê¸°ëŠ¥ ë¹„í™œì„±í™”ë¨)
        // document.addEventListener('keydown', function(e) {
        //     if (e.key === 'Escape') {
        //         closeImageModal();
        //     }
        // });
        
        // ë§ˆí¬ë‹¤ìš´ ë Œë”ë§(ë‹µë³€ì— ì ìš©)
        // marked.js CDN ì¶”ê°€
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
        document.head.appendChild(script);
    </script>
</body>
</html>
